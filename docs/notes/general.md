### General concepts

- `左辺値`（`lvalue`）：メモリ上の特定の場所に置かれ、他のオブジェクトが同じ内容を持っていてもアドレスによって識別することができるオブジェクト
  - `左辺値`じゃない式(267):
    - `int *q = &(x++);` ただし、`int *q = &++x;` は `p` は `x` を指すので左辺値
    - `int &r = (x < y) ? x : 1` → `1` は左辺値じゃない
- `右辺値`（`rvalue`）：右辺値とは違ってアイデンティティを持たない（＝いつでも安全に参照することができるアドレスを持たない）オブジェクト。=> 「低コストでムーブできる値である」と言われる（Rust はもとよりオブジェクトの代入は、所有権の移動によるムーブが発生する）(14)

- `実行時オーバーヘッド`を伴う実装は排除されている。例えば、全オブジェクト内に`管理機能（housekeeping information）`を埋め込んだ上での構築は排除されている。そのため、２個の 16 ビットフィールドを持つ構造をユーザが定義すると、１個の 32 ビットレジスタに収まる。`new`, `delete`, `typeid`, `dynamic_cast`, `throw 演算子`, `try ブロック`を除くと、C++の式と文に対して、実行時の支援が必要となることはない。(17)
- `波括弧 {} で変数を初期化`：暗黙裏の型変換を許容しない。C のような伝統的な`= 代入演算子`で値を C++ でそのまま代入すると、暗黙裏の型変換が行われる。そのため波括弧の使用が推奨される(49)
  - この手法は、`並びによる初期化(list initialization)と呼ばれる`. この初期化では、`縮小変換`を許さない例えば：(169)
    - 整数値は、その値を保持できない他の整数型へ変換されない。例えば、`char から int`
    - 浮動小数点数値はその値を保持できない他の浮動小数点型へ変換されない。例えば、`double から float`
    - `浮動小数点数値`は`整数型`へ変換されない/ `整数値`は`浮動小数点数値`へ変換されない
  - `auto` を使うときは = を使う方が良い。なぜなら例えば`auto z {99};` の型は `initializer_list<int>` になってしまう
    - そのため、`並びではないオブジェクト(container のようなオブジェクト)`の初期化は `=` を利用するのが良い(または併用 `={}`)
- `定数（const）`
  - `const` 修飾子をつける（関数の引数に渡した時に変更されないことを保証）
  - `constexpr` コンパイル時に評価されることを明示し（つまり関数の計算結果を変数に代入する際にその修飾子として使う）、読み取り専用のメモリ領域に配置することを許可するとともに変更不可にする（性能も向上）
    - `constexpr` で修飾された変数は`定数式`にする。そうでないとそれ自体が定数式にならない（例：`const double v = 2.1; constexpr double d = sum(v)`）(51)
- `組み込み型（built-in type）`: `基本型（bool, char など）`・`const 修飾子`・`宣言演算子（declarator operator）(&, *, [])`とで組み合わされる型
- `ユーザー定義型(user-defined type)`: C++ の抽象化機構（abstraction mechanism）(クラスや列挙型など)を使ってユーザーが定義できる型(55)
- `インターフェース`: Vector の`内部データ表現`である 2 つのメンバ `elem`, `sz` は `public メンバであるインターフェース`、すなわち `Vector()`, `operator[]()`, `size()` を介してのみアクセスできる(57)
  - C++ におけるインターフェースは Go や Rust などの impl するためのメソッドの型の集まり、とすることもできるし、
  - 内部データ表現を操作するためのメソッドの定義とすることもできる（Rust のコンテキストで言うとインターフェースに定義されている実際の具象 method）
- `クラスの普遍条件（class invariant）または単に 普遍条件（invariant）`: クラスを初期化するときに必要となる前提条件を表す文であり、これはコンストラクタが保証しなければならないが、その内容は実装者の責任である。例えば、適切に `std::length_error`, `std::bad_alloc` など検出したエラーを呼び出し側に通知する必要がある。呼び出し側はこれらを適切に補足する必要がある。(64)
- `静的アサーション`: エラーを型チェックなどと同様なコンパイルエラーとして検出するための機構である。例えば、`static_assert(4 <= sizeof(int), "integers are too small");`(65)
  - 静的アサーションは、ジェネリックプログラミングの引数型に対して使うことが効果的である
  - static_assert を使うときは、条件部分に使う変数は定数でないといけない
- `インライン化`: 効率を重視すると、単純な演算はインライン化することになる。すなわち`コンストラクタ`、`+=`、`imag()` などの`単純な演算`は、関数呼び出しの機械語が生成されないように実装しなければならない(69)
  　 - クラス内で定義する関数は、デフォルトでインライン化される。
- `資源獲得時初期化(RALL = Resource Acquisition Is Initialization)`: コンストラクタで資源（メモリ）の獲得を行い、デストラクタで必ず資源の解放をする技法（または、`データハンドルモデル（handle-to-data model）`の一つである）
  　- `裸の new 演算`や `裸の delete 演算`を内部に隠蔽する、かつスコープなどから抜けると必ず呼び出されるので資源（メモリ）リークやエラーを防ぎやすくなる(72)
- `コンテナ（Vector など）の初期化`: `std::initializer_list<T>` を使う(73)
- `抽象型(abstract type)`: データの定義ではなく、型を定義したクラス（インターフェースを分割したものとは別）
  - 具象クラス（concrete class）で実装を行うことを想定した関数定義を `仮想関数（virtual function）` と言い、`virtual 修飾子`をつける
  - 仮想関数には `=0` という記法をつけた`純粋仮想(pure virtual)関数`と言う種類の仮想関数があり、その関数は具象クラスで`必ず`実装しなければいけない
  - `具象型`は一般的に`多相型（polymorphic type）`として使われる
- メンバのデストラクタ（クラスのメンバとして持つオブジェクト自身のデストラクタ）は、クラスのデストラクタから暗黙裏に呼ばれる. また、具象型のデストラクタは抽象型のデストラクタを自分のクラス名でオーバーライドできる。
  - クラス階層（class hierarchy）の場合仮想関数の呼び出しの仕組みによって適切なデストラクタが呼ばれる。派生クラスのデストラクタは暗黙裏に基底クラスのデストラクタも呼び出す(78)
- `仮想関数テーブル（vtbl）`: 抽象クラスが実際の具象クラスの実装された関数を呼び出す仕組み（各具象クラスごとに作成して、関数の位置をインデックスを振ってマッピングしたテーブル）(76)
  - メモリのオーバーヘッドは、抽象クラスが保持する`具象クラスへのポインタ`と、`具象クラスの vtbl へのポインタ`
- `unique_ptr`: ユーザーが不要なポインタを delete しない可能性、または失敗する可能性がある。そのため、スコープから抜けるときに不要になったポインタを自動で削除するための機構が`unique_ptr`である(80)
- `資源ハンドル(resource handle)`: ポインタ経由でオブジェクトにアクセスしなければならないこと
  - 配列を使うとリークを起こしていないか木を配る必要があるので、基本的には内部に資源ハンドルを持つ（所有権を表すポインタ） `vector`, `string`, `unique_ptr`を使うこと(195)
  - 反対に資源ハンドルの外部に存在するポインタ（new を使って空き領域にメモリを確保して割り当てた配列など）は自分で `delete` する必要がある、とすると資源管理を単純化することができる(196)
- `クラスオブジェクトのコピー動作`: 以下の２つを検討すると良い.(通常のコピーでは、同じアドレスを参照していまい mutable なオブジェクトになってしまうため)(82)
  - `コピーコンストラクタ（copy constructor）`: `Vector(const Vector& a);`: 必要なメモリを確保し、与えられたオブジェクトと同じ内容をコピーする。そうすると元のオブジェクトとは別のメモリ常に新しいオブジェクトを作成することができる
  - `コピー代入（copy assignment）`: `Vector& operator=(const Vector& a);`: 同様に必要なメモリを確保し、内容をコピーする。その後に元のオブジェクトを削除する. コピーコンストラクタと違うのは、代入操作なので新しいオブジェクトを返却しないといけない点であり、これには　`*this` を使う.
- 階層内のクラスに対して、デフォルトのコピーやムーブを利用すると、ほとんどの場合は惨事につながる。と言うもの、基底を指すポインタだけ与えられても、派生クラスのメンバについては何もわからないからでさる。こう言う場合には、デフォルトのコピー演算、ムーブ演算を削除(delete)するのが良い。(`Shape& operator=(Shape&&) =delete`)
  - また、デストラクタを宣言しておけば、これらの delete を忘れても実害がない。と言うのも、ユーザーが明示的にデストラクタを宣言したクラスに対しては、デフォルトの`ムーブ演算`が暗黙裏には生成されないからである。さらに、この場合の`コピー演算`は非推奨になっている。このため、コンパイラが暗黙裏にデストラクタを作成するとはいえ、ユーザーが明示的にデストラクタを定義する理由の一つである。(85)
- テンプレートの活用で有益なのが`関数オブジェクト（function object）`/` ファンクター（functor）`である：あたかも関数のようにオブジェクトを呼び出すことができる
  - 汎用アルゴリズムの中核となる演算を指定するための、関数オブジェクトを`ポリシーオブジェクト(policy object)` という。
  - 関数オブジェクトを簡潔な内容であれば、ラムダ式（lambda function）を使って全く同じオブジェクトを生成することができる.(`[&](int a) { return a < x; }`)
    - `[&], キャプチャ並び(capture list)`：使っている`局所名（local name: x など、関数で宣言される変数名）`を参照を介してアクセスすることを表す
    - x だけキャプチャしたい場合 `[&x]`, x のコピーとしてオブジェクとを生成した場合は`[=x]`と記述
- `conditional_variable`: lock とイベント待ち: 他のスレッドの結果によってなんならかの条件が成立するまで、別のスレッドを待機させる、と言ったことが可能.(127)
  - 関数の中では、初めに `mutex` を取得し、`conditional_variable.wait(unique_lock<mutex>)` で、`mutex` を解放し wait する。condition が成立したら（待機が終わったら）、再度 `unique_lock<mutex>` を取得し、ロックをかける。
  - condition が成立したことを通知するには、`conditional_variable.notify_one()` で行う
- `tag dispatch（タグ指定）`: overload, single/multi dispatch を前提とした機能で、iterator pattern をアルゴリズムに適用したもの。タグと呼ばれる、組み込みの機能（例えば、`std::random_access_iterator_tag（for vector）`, `std::forward_iterator_tag（for forward_list）`）を関数の引数として使い、コンパイル時に複数のアルゴリズムのうちから１つ選択することができる機能。このタグを取得するために、`iterator_traits` (この場合は container )などから tag を取得することができる。また、こういった関数（/アルゴリズム: 引数あるいは返却値として、ある型が与えられて、コンパイル時に評価される関数）を`型関数(type function)`と言う。(132)
- `型述語`：型に関する基本的な情報を返却するための単純な`型関数`である。このような述語（predicate）は、`<type_traits>`で提供される
- `make_pair()` を使うと、明示的な型の記述が不要になるため pair の作成が容易になる(135)
- その機能に、理屈通りで容易に実装できる別の方法が複数あれば、その機能は、`定義されない（undefined）`ではなく、`指定されない（unspecified）`あるいは、`処理系定義（implementation defined）`である(144)
- 標準が指定しない、あるいは、定義しない、とするものを使わないように努力することは、そのための時間と労力に見合うはずである(145)
- `void`: `返却値を返さない関数の型`、または`型がわからないオブジェクトを指すポインタの型`として利用(157)
- `size_t`: 処理系定義の符号無し整数型、`ptrdiff_t`: 要素数を求めるための、ポインタどうしの差の演算結果を保持できる. このように標準ヘッダは処理系に依存しない型の大きさを定義した`型別名`を提供する（`<cstdint>`, `<stddef>`など）
- `値を指定する宣言`は、全て`定義`である(162)
- `関数定義`と`名前空間定義`を除くと、`全ての宣言`はセミコロンで終了する(162)
- `予約済みの名前`：`下線で始まる非局所変数`, `２個の下線を含む名前`、`下線で始まって直後に大文字が続く名前`など（`_class`, `trouble__ahead`, `_Foo` など）
- `参照はずし`: C++ では参照は、式の中で暗黙裏に反証外しを行われている(Go と同じ) `void g(int& v) { auto x = v;}` この場合、`&v` は暗黙裏に参照外しされ、`v` となる。もし参照としてオブジェクトを保持したいなら、`auto &x = v;` とすれば良い.
- `配列`を`空き領域`に割り当てた場合（`new int[40]`をした場合。）は、必ず使用後に１度削除しなければならない（`delete[]`）。`スタック領域`（`int a[20]`）や、静的に割り当てた場合（`静的記憶域`に格納した場合、global, 関数・クラス内の static をつけて宣言した変数など）は`delete[]`してはいけない。
- C と同様に初期化された配列に再代入することはできない。そのためオブジェクトの集合を代入したいときは、vector, array, valarray を使う(184)
- `文字列リテラル`: C++ では const ととして定義する。もし、非 const にしたいなら配列で宣言すること(185):
  - const: `const char* p = "Plate"` (const は静的に割り当てられるため、関数の返却値としても安全に利用できる（関数終了後も存在し続ける・アドレスが変わらない・move しない・）)
  - 非 const: `char p[] = "Plate"`
  - さらに文字列リテラルは最適化のため全く同じ内容の文字列を同じアドレスとして保持する場合がある。その際に別々の変数を比較して同じアドレスを指しているかどうか（同じ文字列かどうではなく）で確認することができる
- `ポインタ`の扱いは大変（メンバへのアクセス方法などの違い）なので、`参照`を利用する
  - `参照`の主な用途は、`関数`あるいは`多重定義された演算子`の`引数`と`返却値`
  - 参照の種類:
    - `左辺値参照`(`lvalue reference`): その値を変更したいオブジェクトへの参照(`v[2] = 7;`)
    - `const 参照`(`const reference`): その値を変更したくないオブジェクトへの参照（定数など）(`f(const &v){...}`)
    - `右辺値参照`(`rvalue reference`): 利用した後で、その値を保持する必要がないオブジェクト（例えば、一時オブジェクト）への参照(`v.push_back(v[2]);`)
      - 高コストなコピー演算を、低コストなムーブ動作に置換できるかどうかを決定するのは、参照が一時オブジェクトを参照しているかどうかに依存する
      - その値を保持する必要がない時とは例えば`局所変数`のを返す関数の返却値があげられる
  - 参照はオブジェクトを指す. 参照から参照先のオブジェクトへのポインタを取得する場合は、`int var = 0; int &rr {val}; int *p = &rr;` のように`&rr`する
  - `単なる参照`と`const の参照`では初期化時の挙動が異なる
    - `単なる参照`: 異なる型で初期化することはできない
    - `const の参照`: 異なる型で初期化することはできる. 異なる場合、const への参照型へキャストされる. 例えば、`const double &cdr {1}` は double 型になる(199)
      - このキャストが行われる際には、temp の変数が作成されこれは参照のスコープかを抜け出すまで存在し続ける(199)
    - `Map` 型の場合は線形探索などの函数の返却値に参照が使用される。と言うのも、返却値の value をよく更新されるのに使用されることが多いからである。
- `参照への参照`: 左辺値参照が常に勝つ. (`参照崩壊`（`reference collapse`）と呼ばれる)(204)
  - 例) `int && && -> int&&`, `int && & -> int&`, `int & && -> int&`, `int & & -> int &` となる.
- ポインタなどの組み込み型どうしの演算（例えば、`&a + &b` のように参照演算子がついた型どうしの演算）を行う演算子は（再）定義できない
  - `a + b` のように非組み込み型であれば問題なく、この場合参照を引数として `+` `-` などの演算子定義することができる
- `sturct`: struct は通常アライメントされるので、メモリを大きく占めるメンバを先に宣言するとことで穴を埋めることができる（可読性が失われる可能性があるが）
  - `アクセス指定子`(`public`, `private`, `protected`): を複数利用すると、レイアウトが変わってしまう(212)
  - `struct` は型の宣言さえすれば、実装前に使用することができる(213)
  - また `非 struct` と同一名の変数や関数などを宣言することできる（これは同名で多重定義しても `struct キーワード`の前置きが必要で区別できるため. ただ曖昧さを排除するために推奨はされない）
  - `struct` はたとえメンバの構成が同一でも、個々の struct はそれぞれが別々の型となるので、比較演算子での比較は常に `false` になる
- `POD`(`Plain Old Data`): `C 互換データ`: 複雑なクラスレイアウトや、構築、コピー、ムーブなどのユーザ定義の瀬マンティクスを配慮することなく、`単なるデータ`として利用できるオブジェクトである. `POD`であるための条件として主に以下の 3 つを満たす必要がある(218):
  - `標準レイアウト型`(`standard layout type`)
  - `トリビアルにコピー可能な型`（`trivially copyable type`）
    - `トリビアル型`（`trivial type`）:
      - トリビアルなデフォルトコンストラクタ
      - トリビアルなコピー動作及びムーブ動作
  - `トリビアルなデフォルトコンストラクタを持つ型`:　`struct{ int a; S(int a): a(aa){} }; // POD ではない（デフォルトコンストラクタがない）`(デフォルトの詳細は`17.6`)
  - 標準ライブラリ `<type_traits>` の `is_pod<T>` で `T` が `POD` かどうかチェックできる(219)
- `共用体(Union)`: `タグ付き共用体(tagged union)` あるいは、`判別共用体(discriminated union)` を使って Union の誤用を防ぐための実装を施すことができる(224)
  - この場合クラスのフィールドとして Union を持つことになるが、`無名共用体(anonymous union)（無名共用体は型はなくオブジェクトである）`を宣言してその各メンバには直接アクセスすることでアクセスする
  - string などの変種を使う場合は、デストラクタや setter など所々で`'明示的に'`解体(`s.~string();`)するようにすることで可読性や誤用を防ぐことができる
- `選択文`:
  - `if 文`:
    - 整数定数を渡した時は暗黙裏に bool に変換され、`x != 0` の判定が行われる
    - pointer を渡した時は暗黙裏に nullptr かどうか `p != nullptr` の判定が行われる
    - enum は暗黙裏に bool に変換され、整数定数と同様に判定される
    - enum class は暗黙裏に変換`されない`
    - `条件内の宣言`を積極的に活用する. スコープを局所化でき、ソースコードがコンパクトになる(240)
      - 条件での宣言は、`単一の変数`、あるいは`const の宣言と初期化`に限られる
  - `switch 文`:
    - case ラベルに用いられる式は、`汎整数型`か`列挙体型の定数式`でなければならない
    - `汎整数型`でなければならないため、string は使用できないが、ハッシュ値を用いることで実現できる [ref](https://stackoverflow.com/questions/650162/why-the-switch-statement-cannot-be-applied-on-strings)
    - switch 分内で変数が必要であれば、その宣言をスコープ内に入れ、その利用もブロック内に制限すれば良い。その具体例はとして `prim()` の利用である(240)
- `通常の算術変換(the usual arithmetic conversion)`: 算術演算に置いてメモリの占有領域が大きい型に自動的に格上げする手法で、C++ でもそれを採用(267)(279)
- `評価順序`:
  - 式の評価順序に決まりはないので、`x = f() + g()` のような場合、`f()`, `g()` のどちらが先に評価されるかどうかはわからない
  - `x[i] = ++i;` のような式では、`x[1]`または `x[2]`になりえるので、読み込みと書き込みを同じ式に書くのは避ける
  - 評価順序が明確にするための演算子を活用する:
    - `順次演算子`では左から先に評価される: `f( (v[i], ++i) )` (`f(v[i], ++i)`とした場合の動作は定義されない)
- `一時オブジェクト（temporary）`: コンパイラが中間結果を保持するために導入するオブジェクト. `v = x+y*z` のうち `y*z`の計算結果を一時オブジェクトに置いておき、後から x との演算に利用
  - 一時オブジェクトは`完全式(full expression)` が評価された後に完全に解体（解放）される. そのため思わぬ挙動を生む可能性がある. 一時オブジェクトへの参照を取得しようとする実装をしないようにする. 例えば、`const char* cs = (string1 + string2).c_str();` は動作しない
  - 一時オブジェクトは `const の参照`や`名前付きオブジェクトの初期菓子`として利用できる。この場合一時オブジェクトはそのオブジェクトがスコープから抜けて解体される時に一緒に解体される
  - `局所変数への参照を返すのは誤りである`ことと`一時オブジェクトは 非 const 左辺値参照にバインドできない`ことを覚えておく(271)
  - `式の中で明示的にコンストラクタを呼ぶと一時オブジェクトが生成される`(`s.move(string(n, ch))` → string コンストラクタを呼び出して直接 move に渡す → 一時オブジェクトが作成される)
- `縮小変換(narrowing conversion)` せざるをえない場合は、`narrow_cast<>()` の利用を検討
- `特殊化(specialization)`- テンプレートはデフォルトでたった一つの定義でユーザーがから考えられるあらゆるテンプレート引数（あるいはその組み合わせ）で利用できるようになる. しかし、このことは、テンプレート開発者にとって必ずしも理にかなっていることではない. "テンプレート引数がポインタだったら、こちらの実装を利用して、ポインタでなければあちらの実装を利用する"など、設計上の問題の多くは、テンプレートの大体実装をあらかじめ定義しておき、実際の利用時に与えられたテンプレート引数に基づいて、コンパイラに選択させることで解決できる。`テンプレートのこのような大体実装は`、`ユーザ定義特殊化(user-defined specialization)` または単に`ユーザ特殊化(user specialization)`と呼ばれる.(730)
- 名前付きオブジェクトの生存期間はスコープが決定するが、スコープに依存せずに生存可能なオブジェクトを作成すると役立つことも多い。例えば、関数の返却値として名前付きオブジェクトの参照を返す時などである（この際は返却先で delete で解体する）。ただ返却値として利用するために new を使うのではなく、move を使って所有権を移動させることで所有者がスコープを抜けた時に自動で解体されるようにする方が object leak を防ぐには better(288)

  - そのための機構 `new`（によってメモリを割り当てる）であり、それを解体するのが `delete` である. (`空き容量 (free store) 上にある`、`ヒープ(heap) 上にある`、 `動的メモリ(dynamic memory) の中にある`、ともいう.)
  - `局所変数(local variable)`（関数内で宣言する変数）で`裸の new 演算子`は避ける（unique_pointer などでラップする）
    - `delete[]` で解体できるのは、`new で確保した配列をさすポインタ`か、あるいは、`空ポインタ`であり、空ポインタの場合は何もしない.

- `配置構文(placement syntax)`: new では空領域にメモリを確保するが、特定のアドレスに割り当てることもできる. この場合、new にそのアドレスを void* 型にキャストして渡す(`reinterpret_cast<void*>(0xF00F)`) この時確保されるオブジェクトの大きさは暗黙裏に決定される
- `nothrow new`: `new(nothrow) int[n]` のように `nothrow` を引数に渡すと、`bac_alloc 例外`が送出されずに `nullptr` が返却されるようになる
- `並び`: `{} 構文` 型修飾される場合その型で初期化を行う. 型修飾されていない場合は利用されている文脈に応じて型決定を行う.
  - `修飾並び`: S{..} のように型修飾されている並び(`S v{7,8}; // 変数の直接初期化 v = S{8,9}; // 修飾並びによる代入`)
  - `非修飾並び`: {} のように型修飾されてない並び(`int v{1} // 変数の直接初期化 v = {2}; // 非修飾並びによる代入`)
- `ラムダ`: 関数オブジェクトを定義する簡略法
  - `ラムダ`を用いる時は呼び出す川の生存期間よりも長くなる可能性がある場合は、参照としてキャプチャするかどうか慎重に判断する
  - `ラムダ`内でも名前空間内の名前を利用できるので、わざわざキャプチャする必要があるかどうか確認すること
- `関数`:
  - `引数の受け渡し`:
    - 関数名の後ろに置く`()`は`呼び出し演算子（call operator）`または、`アプリケーション演算子(application operator)` と呼ばれる
    - 関数を呼び出すと、関数の`仮引数（formal argument、またはパラメータ（parameter））`のためのメモリ領域が割り当てられ、個々の`仮引数`が対応する`実引数`によって初期化される
    - 引数に pointer を渡しても元のオブジェクトは変化しない（変更できるのは参照で渡されたオブジェクトのみ）. もし pointer の指すオブジェクトを変更したい場合は、参照で渡す(`void foo(type *&in) {...}`)
  - 関数に渡す引数は明示的に型変換される(`double sqrt(double); sqrt(2);` とすると暗黙裏に `sqrt(double{2})` なり型変換される)(313)
  - 行列などでは入れ子のループには内積を用いると良い
  - 関数にバグが忍び込むのは、アルゴリズムの一部しか確認できないような時であるので、約 40 行を関数の上限とするようにする（ビャーネストラウストラップは 7 行を理想としている）
  - 関数の呼び出しがコストになることはあまりない。もし問題となる場合は、`インライン化`すればコストを削減できる
  - 関数宣言の構成要素(315):
    - `inline`: 関数呼び出し箇所に、関数本体を埋め込んで欲しいということを表す
      - `相互再帰`や`再起呼出し`を行うかどうかが、与えられた値に依存する関数などがインライン関数となることもあるため、インラインに必ず展開されるという保証はない(319)
    - `constexpr`: `関数の引数が定数式である場合`に、関数評価がコンパイル時に可能であることを表す
    - `noexcept`: `関数が例外を送出しないことを表す`
    - `[[noreturn]]`: 通常の呼び出し・リターンの機構下でも、`関数がリターンしないことを表す`
    - `結合指定`: 例えば `static` など
  - 引数; - `関数宣言`の引数は省略可能で、その引数名と`関数定義（関数本体を伴う関数宣言）`の引数名は違っていても良い
  - 関数定義の引数に名前を与えなくても良いが、その場合その引数を使用しないことを表す（コードの単純化や将来の拡張のために使う）
  - 後置形式の返却型を使う重要な用途が、引数に依存する返却型を持つ関数テンプレート宣言におけるものである. (`auto product(const vector<T>& x, const vector<U>& y) -> decltype(x*y)`)
  - main 関数を除いて、void 以外は必ず値を返さないといけない
  - 関数が値を返却するセマンティクス（`return`）は、引数受け渡しの背マンティクスと同様にコピー初期化と同じ。そのため、返却型の変数を初期化し、暗黙裏に型の変換が行われる (`double f() {return 1;} // 1 は double{1}`)(317)
  - コマンドライン引数を処理する場合は、伝統的な C スタイルの手法ではなく、コンテナを使った手法を取り入れる.
  - デフォルト引数を積極的に取り入れることでメンバ関数の記述量を圧倒的に軽減・保守性を高めることができる
- `One Definition Rule`: objects and non-inline functions cannot have more than one definition in the entire program and template and types cannot have more than one definition by translation unit.[Ref](https://en.wikipedia.org/wiki/One_Definition_Rule)
- `多重定義(overloading)`:
  - 同じ関数名で異なる別々の引数型に対して別々の処理を実装する（コンパイラが仮引数と実引数の型を比較して関数を`自動解決`する、また`返却型`は考慮されない）:
    - 関数の宣言順序は無関係
    - コンパイラは引数の一致度が一番高い関数を選択する（次のような場合は、優先度が同一の関数が複数あるためエラーとなる: `f(double, double); f(int, int); void main(){ f(2.0, 2); }`）
    - `Multi dispatch（複数の引数の自動解決）` をサポートする
    - 一致する関数がなければコンパイルエラーとなる
    - 詳細な自動解決の詳細は(334)を参照
  - テンプレートは多重定義された関数を一括りにする体型的方法を提供する:
    - `関数テンプレート`は、`引数一式に対する特殊化の結果に対して多重定義解決規則を適用することによって処理される`(335)
    - `{} 並びを使った場合の多重定義(初期化子並びが優先される)`と、`テンプレートの右辺値参照引数`には、別の規則が適用される(335)
  - 継承による同名関数の定義は多重定義にはならない.
    - `クラススコープや名前空間をまたがる多重定義`が必要であれば、`using 宣言`や `sing 指令`を用いる.
    - `実引数依存探索`を用いると名前空間をまたがる多重定義が可能
  - `多重定義`のメリット:
    - 関数の呼び出しの際に行われる引数の型変換のうちエラーに繋がりやすい`縮小変換`が起きるのを防ぐ（多重定義による変換では、`標準変換`が行われるのぜより安全な変換になる(334)）
  - 手動による解決:
    - `static_cast<int *>(0)` のように明示的型変換を用いる方法もあるが、このような一時凌ぎでは呼び出す箇所全て同じようにしないといけなくなってしまう
- `事前条件`と`事後条件`(338):
  - 関数を呼び出した時に、引数の型はコンパイラやリンカが保証するが、実際に入ってくる値が不正な値に対処するのはプログラマの責任である.
  - `事前条件(precondition)`: 関数が呼び出された時点で保証されるべき論理的な規則
  - `事後条件(postcondition)`: 関数がリターンした時点で保証されるべき論理的な規則
  - 関数が非局所オブジェクトを利用・変更する場合は、その影響を考慮してドキュメント化しなければならない
