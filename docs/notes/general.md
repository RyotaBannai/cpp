### General concepts

- `左辺値`（`lvalue`）：メモリ上の特定の場所に置かれ、他のオブジェクトが同じ内容を持っていてもアドレスによって識別することができるオブジェクト
  - `左辺値`じゃない式(267):
    - `int *q = &(x++);` ただし、`int *q = &++x;` は `p` は `x` を指すので左辺値
    - `int &r = (x < y) ? x : 1` → `1` は左辺値じゃない
- `右辺値`（`rvalue`）：右辺値とは違ってアイデンティティを持たない（＝いつでも安全に参照することができるアドレスを持たない）オブジェクト。=> 「低コストでムーブできる値である」と言われる（Rust はもとよりオブジェクトの代入は、所有権の移動によるムーブが発生する）(14)

- `実行時オーバーヘッド`を伴う実装は排除されている。例えば、全オブジェクト内に`管理機能（housekeeping information）`を埋め込んだ上での構築は排除されている。そのため、２個の 16 ビットフィールドを持つ構造をユーザが定義すると、１個の 32 ビットレジスタに収まる。`new`, `delete`, `typeid`, `dynamic_cast`, `throw 演算子`, `try ブロック`を除くと、C++の式と文に対して、実行時の支援が必要となることはない。(17)
- `波括弧 {} で変数を初期化`：暗黙裏の型変換を許容しない。C のような伝統的な`= 代入演算子`で値を C++ でそのまま代入すると、暗黙裏の型変換が行われる。そのため波括弧の使用が推奨される(49)
  - この手法は、`並びによる初期化(list initialization)と呼ばれる`. この初期化では、`縮小変換`を許さない例えば：(169)
    - 整数値は、その値を保持できない他の整数型へ変換されない。例えば、`char から int`
    - 浮動小数点数値はその値を保持できない他の浮動小数点型へ変換されない。例えば、`double から float`
    - `浮動小数点数値`は`整数型`へ変換されない/ `整数値`は`浮動小数点数値`へ変換されない
  - `auto` を使うときは = を使う方が良い。なぜなら例えば`auto z {99};` の型は `initializer_list<int>` になってしまう
    - そのため、`並びではないオブジェクト(container のようなオブジェクト)`の初期化は `=` を利用するのが良い(または併用 `={}`)
- `定数（const）`
  - `const` 修飾子をつける（関数の引数に渡した時に変更されないことを保証）
  - `constexpr` コンパイル時に評価されることを明示し（つまり関数の計算結果を変数に代入する際にその修飾子として使う）、読み取り専用のメモリ領域に配置することを許可するとともに変更不可にする（性能も向上）
    - `constexpr` で修飾された変数は`定数式`にする。そうでないとそれ自体が定数式にならない（例：`const double v = 2.1; constexpr double d = sum(v)`）(51)
- `組み込み型（built-in type）`: `基本型（bool, char など）`・`const 修飾子`・`宣言演算子（declarator operator）(&, *, [])`とで組み合わされる型
- `ユーザー定義型(user-defined type)`: C++ の抽象化機構（abstraction mechanism）(クラスや列挙型など)を使ってユーザーが定義できる型(55)
- `インターフェース`: Vector の`内部データ表現`である 2 つのメンバ `elem`, `sz` は `public メンバであるインターフェース`、すなわち `Vector()`, `operator[]()`, `size()` を介してのみアクセスできる(57)
  - C++ におけるインターフェースは Go や Rust などの impl するためのメソッドの型の集まり、とすることもできるし、
  - 内部データ表現を操作するためのメソッドの定義とすることもできる（Rust のコンテキストで言うとインターフェースに定義されている実際の具象 method）
- `クラスの普遍条件（class invariant）または単に 普遍条件（invariant）`: クラスを初期化するときに必要となる前提条件を表す文であり、これはコンストラクタが保証しなければならないが、その内容は実装者の責任である。例えば、適切に `std::length_error`, `std::bad_alloc` など検出したエラーを呼び出し側に通知する必要がある。呼び出し側はこれらを適切に補足する必要がある。(64)
- `静的アサーション`: エラーを型チェックなどと同様なコンパイルエラーとして検出するための機構である。例えば、`static_assert(4 <= sizeof(int), "integers are too small");`(65)
  - 静的アサーションは、ジェネリックプログラミングの引数型に対して使うことが効果的である
  - static_assert を使うときは、条件部分に使う変数は定数でないといけない
- `インライン化`: 効率を重視すると、単純な演算はインライン化することになる。すなわち`コンストラクタ`、`+=`、`imag()` などの`単純な演算`は、関数呼び出しの機械語が生成されないように実装しなければならない(69)
  - クラス内で定義する関数は、デフォルトでインライン化される。
- `資源獲得時初期化(RALL = Resource Acquisition Is Initialization)`: コンストラクタで資源（メモリ）の獲得を行い、デストラクタで必ず資源の解放をする技法（または、`データハンドルモデル（handle-to-data model）`の一つである）
  - `裸の new 演算`や `裸の delete 演算`を内部に隠蔽する、かつスコープなどから抜けると必ず呼び出されるので資源（メモリ）リークやエラーを防ぎやすくなる(72)
- `コンテナ（Vector など）の初期化`: `std::initializer_list<T>` を使う(73)
- `抽象型(abstract type)`: データの定義ではなく、型を定義したクラス（インターフェースを分割したものとは別）
  - 具象クラス（concrete class）で実装を行うことを想定した関数定義を `仮想関数（virtual function）` と言い、`virtual 修飾子`をつける
  - 仮想関数には `=0` という記法をつけた`純粋仮想(pure virtual)関数`と言う種類の仮想関数があり、その関数は具象クラスで`必ず`実装しなければいけない
  - `具象型`は一般的に`多相型（polymorphic type）`として使われる
- メンバのデストラクタ（クラスのメンバとして持つオブジェクト自身のデストラクタ）は、クラスのデストラクタから暗黙裏に呼ばれる. また、具象型のデストラクタは抽象型のデストラクタを自分のクラス名でオーバライドできる。
  - クラス階層（class hierarchy）の場合仮想関数の呼び出しの仕組みによって適切なデストラクタが呼ばれる。派生クラスのデストラクタは暗黙裏に基底クラスのデストラクタも呼び出す(78)
- `仮想関数テーブル（vtbl）`: 抽象クラスが実際の具象クラスの実装された関数を呼び出す仕組み（各具象クラスごとに作成して、関数の位置をインデックスを振ってマッピングしたテーブル）(76)
  - メモリのオーバーヘッドは、抽象クラスが保持する`具象クラスへのポインタ`と、`具象クラスの vtbl へのポインタ`
- `unique_ptr`: ユーザーが不要なポインタを delete しない可能性、または失敗する可能性がある。そのため、スコープから抜けるときに不要になったポインタを自動で削除するための機構が`unique_ptr`である(80)
- `資源ハンドル(resource handle)`: ポインタ経由でオブジェクトにアクセスしなければならないこと
  - 配列を使うとリークを起こしていないか木を配る必要があるので、基本的には内部に資源ハンドルを持つ（所有権を表すポインタ） `vector`, `string`, `unique_ptr`を使うこと(195)
  - 反対に資源ハンドルの外部に存在するポインタ（new を使って空き領域にメモリを確保して割り当てた配列など）は自分で `delete` する必要がある、とすると資源管理を単純化することができる(196)
- `クラスオブジェクトのコピー動作`: 以下の２つを検討すると良い.(通常のコピーでは、同じアドレスを参照していまい mutable なオブジェクトになってしまうため)(82)
  - `コピーコンストラクタ（copy constructor）`: `Vector(const Vector& a);`: 必要なメモリを確保し、与えられたオブジェクトと同じ内容をコピーする。そうすると元のオブジェクトとは別のメモリ常に新しいオブジェクトを作成することができる
  - `コピー代入（copy assignment）`: `Vector& operator=(const Vector& a);`: 同様に必要なメモリを確保し、内容をコピーする。その後に元のオブジェクトを削除する. コピーコンストラクタと違うのは、代入操作なので新しいオブジェクトを返却しないといけない点であり、これには　`*this` を使う.
- 階層内のクラスに対して、デフォルトのコピーやムーブを利用すると、ほとんどの場合は惨事につながる。と言うもの、基底を指すポインタだけ与えられても、派生クラスのメンバについては何もわからないからでさる。こう言う場合には、デフォルトのコピー演算、ムーブ演算を削除(delete)するのが良い。(`Shape& operator=(Shape&&) =delete`)
  - また、デストラクタを宣言しておけば、これらの delete を忘れても実害がない。と言うのも、ユーザーが明示的にデストラクタを宣言したクラスに対しては、デフォルトの`ムーブ演算`が暗黙裏には生成されないからである。さらに、この場合の`コピー演算`は非推奨になっている。このため、コンパイラが暗黙裏にデストラクタを作成するとはいえ、ユーザーが明示的にデストラクタを定義する理由の一つである。(85)
- テンプレートの活用で有益なのが`関数オブジェクト（function object）`/` ファンクター（functor）`である：あたかも関数のようにオブジェクトを呼び出すことができる
  - 汎用アルゴリズムの中核となる演算を指定するための、関数オブジェクトを`ポリシーオブジェクト(policy object)` という。
  - 関数オブジェクトを簡潔な内容であれば、ラムダ式（lambda function）を使って全く同じオブジェクトを生成することができる.(`[&](int a) { return a < x; }`)
    - `[&], キャプチャ並び(capture list)`：使っている`局所名（local name: x など、関数で宣言される変数名）`を参照を介してアクセスすることを表す
    - x だけキャプチャしたい場合 `[&x]`, x のコピーとしてオブジェクとを生成した場合は`[=x]`と記述
- `conditional_variable`: lock とイベント待ち: 他のスレッドの結果によってなんならかの条件が成立するまで、別のスレッドを待機させる、と言ったことが可能.(127)
  - 関数の中では、初めに `mutex` を取得し、`conditional_variable.wait(unique_lock<mutex>)` で、`mutex` を解放し wait する。condition が成立したら（待機が終わったら）、再度 `unique_lock<mutex>` を取得し、ロックをかける。
  - condition が成立したことを通知するには、`conditional_variable.notify_one()` で行う
- `tag dispatch（タグ指定）`: overload, single/multi dispatch を前提とした機能で、iterator pattern をアルゴリズムに適用したもの。タグと呼ばれる、組み込みの機能（例えば、`std::random_access_iterator_tag（for vector）`, `std::forward_iterator_tag（for forward_list）`）を関数の引数として使い、コンパイル時に複数のアルゴリズムのうちから１つ選択することができる機能。このタグを取得するために、`iterator_traits` (この場合は container )などから tag を取得することができる。また、こういった関数（/アルゴリズム: 引数あるいは返却値として、ある型が与えられて、コンパイル時に評価される関数）を`型関数(type function)`と言う。(132)
- `型述語`：型に関する基本的な情報を返却するための単純な`型関数`である。このような述語（predicate）は、`<type_traits>`で提供される
- `make_pair()` を使うと、明示的な型の記述が不要になるため pair の作成が容易になる(135)
- その機能に、理屈通りで容易に実装できる別の方法が複数あれば、その機能は、`定義されない（undefined）`ではなく、`指定されない（unspecified）`あるいは、`処理系定義（implementation defined）`である(144)
- 標準が指定しない、あるいは、定義しない、とするものを使わないように努力することは、そのための時間と労力に見合うはずである(145)
- `void`: `返却値を返さない関数の型`、または`型がわからないオブジェクトを指すポインタの型`として利用(157)
- `size_t`: 処理系定義の符号無し整数型、`ptrdiff_t`: 要素数を求めるための、ポインタどうしの差の演算結果を保持できる. このように標準ヘッダは処理系に依存しない型の大きさを定義した`型別名`を提供する（`<cstdint>`, `<stddef>`など）
- `値を指定する宣言`は、全て`定義`である(162)
- `関数定義`と`名前空間定義`を除くと、`全ての宣言`はセミコロンで終了する(162)
- `予約済みの名前`：`下線で始まる非局所変数`, `２個の下線を含む名前`、`下線で始まって直後に大文字が続く名前`など（`_class`, `trouble__ahead`, `_Foo` など）
- `参照はずし`: C++ では参照は、式の中で暗黙裏に反証外しを行われている(Go と同じ) `void g(int& v) { auto x = v;}` この場合、`&v` は暗黙裏に参照外しされ、`v` となる。もし参照としてオブジェクトを保持したいなら、`auto &x = v;` とすれば良い.
- `配列`を`空き領域`に割り当てた場合（`new int[40]`をした場合。）は、必ず使用後に１度削除しなければならない（`delete[]`）。`スタック領域`（`int a[20]`）や、静的に割り当てた場合（`静的記憶域`に格納した場合、global, 関数・クラス内の static をつけて宣言した変数など）は`delete[]`してはいけない。
- C と同様に初期化された配列に再代入することはできない。そのためオブジェクトの集合を代入したいときは、vector, array, valarray を使う(184)
- `文字列リテラル`: C++ では const ととして定義する。もし、非 const にしたいなら配列で宣言すること(185):
  - const: `const char* p = "Plate"` (const は静的に割り当てられるため、関数の返却値としても安全に利用できる（関数終了後も存在し続ける・アドレスが変わらない・move しない・）)
  - 非 const: `char p[] = "Plate"`
  - さらに文字列リテラルは最適化のため全く同じ内容の文字列を同じアドレスとして保持する場合がある。その際に別々の変数を比較して同じアドレスを指しているかどうか（同じ文字列かどうではなく）で確認することができる
- `ポインタ`の扱いは大変（メンバへのアクセス方法などの違い）なので、`参照`を利用する
  - `参照`の主な用途は、`関数`あるいは`多重定義された演算子`の`引数`と`返却値`
  - 参照の種類:
    - `左辺値参照`(`lvalue reference`): その値を変更したいオブジェクトへの参照(`v[2] = 7;`)
    - `const 参照`(`const reference`): その値を変更したくないオブジェクトへの参照（定数など）(`f(const &v){...}`)
    - `右辺値参照`(`rvalue reference`): 利用した後で、その値を保持する必要がないオブジェクト（例えば、一時オブジェクト）への参照(`v.push_back(v[2]);`)
      - 高コストなコピー演算を、低コストなムーブ動作に置換できるかどうかを決定するのは、参照が一時オブジェクトを参照しているかどうかに依存する
      - その値を保持する必要がない時とは例えば`局所変数`のを返す関数の返却値があげられる
  - 参照はオブジェクトを指す. 参照から参照先のオブジェクトへのポインタを取得する場合は、`int var = 0; int &rr {val}; int *p = &rr;` のように`&rr`する
  - `単なる参照`と`const の参照`では初期化時の挙動が異なる
    - `単なる参照`: 異なる型で初期化することはできない
    - `const の参照`: 異なる型で初期化することはできる. 異なる場合、const への参照型へキャストされる. 例えば、`const double &cdr {1}` は double 型になる(199)
      - このキャストが行われる際には、temp の変数が作成されこれは参照のスコープかを抜け出すまで存在し続ける(199)
    - `Map` 型の場合は線形探索などの函数の返却値に参照が使用される。と言うのも、返却値の value をよく更新されるのに使用されることが多いからである。
- `参照への参照`: 左辺値参照が常に勝つ. (`参照崩壊`（`reference collapse`）と呼ばれる)(204)
  - 例) `int && && -> int&&`, `int && & -> int&`, `int & && -> int&`, `int & & -> int &` となる.
- ポインタなどの組み込み型どうしの演算（例えば、`&a + &b` のように参照演算子がついた型どうしの演算）を行う演算子は（再）定義できない
  - `a + b` のように非組み込み型であれば問題なく、この場合参照を引数として `+` `-` などの演算子定義することができる
- `sturct`: struct は通常アライメントされるので、メモリを大きく占めるメンバを先に宣言するとことで穴を埋めることができる（可読性が失われる可能性があるが）
  - `アクセス指定子`(`public`, `private`, `protected`): を複数利用すると、レイアウトが変わってしまう(212)
  - `struct` は型の宣言さえすれば、実装前に使用することができる(213)
  - また `非 struct` と同一名の変数や関数などを宣言することできる（これは同名で多重定義しても `struct キーワード`の前置きが必要で区別できるため. ただ曖昧さを排除するために推奨はされない）
  - `struct` はたとえメンバの構成が同一でも、個々の struct はそれぞれが別々の型となるので、比較演算子での比較は常に `false` になる
- `POD`(`Plain Old Data`): `C 互換データ`: 複雑なクラスレイアウトや、構築、コピー、ムーブなどのユーザ定義の瀬マンティクスを配慮することなく、`単なるデータ`として利用できるオブジェクトである. `POD`であるための条件として主に以下の 3 つを満たす必要がある(218):
  - `標準レイアウト型`(`standard layout type`)
  - `トリビアルにコピー可能な型`（`trivially copyable type`）
    - `トリビアル型`（`trivial type`）:
      - トリビアルなデフォルトコンストラクタ
      - トリビアルなコピー動作及びムーブ動作
  - `トリビアルなデフォルトコンストラクタを持つ型`:　`struct{ int a; S(int a): a(aa){} }; // POD ではない（デフォルトコンストラクタがない）`(デフォルトの詳細は`17.6`)
  - 標準ライブラリ `<type_traits>` の `is_pod<T>` で `T` が `POD` かどうかチェックできる(219)
- `共用体(Union)`: `タグ付き共用体(tagged union)` あるいは、`判別共用体(discriminated union)` を使って Union の誤用を防ぐための実装を施すことができる(224)
  - この場合クラスのフィールドとして Union を持つことになるが、`無名共用体(anonymous union)（無名共用体は型はなくオブジェクトである）`を宣言してその各メンバには直接アクセスすることでアクセスする
  - string などの変種を使う場合は、デストラクタや setter など所々で`'明示的に'`解体(`s.~string();`)するようにすることで可読性や誤用を防ぐことができる
- `選択文`:
  - `if 文`:
    - 整数定数を渡した時は暗黙裏に bool に変換され、`x != 0` の判定が行われる
    - pointer を渡した時は暗黙裏に nullptr かどうか `p != nullptr` の判定が行われる
    - enum は暗黙裏に bool に変換され、整数定数と同様に判定される
    - enum class は暗黙裏に変換`されない`
    - `条件内の宣言`を積極的に活用する. スコープを局所化でき、ソースコードがコンパクトになる(240)
      - 条件での宣言は、`単一の変数`、あるいは`const の宣言と初期化`に限られる
  - `switch 文`:
    - case ラベルに用いられる式は、`汎整数型`か`列挙体型の定数式`でなければならない
    - `汎整数型`でなければならないため、string は使用できないが、ハッシュ値を用いることで実現できる [ref](https://stackoverflow.com/questions/650162/why-the-switch-statement-cannot-be-applied-on-strings)
    - switch 分内で変数が必要であれば、その宣言をスコープ内に入れ、その利用もブロック内に制限すれば良い。その具体例はとして `prim()` の利用である(240)
- `通常の算術変換(the usual arithmetic conversion)`: 算術演算に置いてメモリの占有領域が大きい型に自動的に格上げする手法で、C++ でもそれを採用(267)(279)
- `評価順序`:
  - 式の評価順序に決まりはないので、`x = f() + g()` のような場合、`f()`, `g()` のどちらが先に評価されるかどうかはわからない
  - `x[i] = ++i;` のような式では、`x[1]`または `x[2]`になりえるので、読み込みと書き込みを同じ式に書くのは避ける
  - 評価順序が明確にするための演算子を活用する:
    - `順次演算子`では左から先に評価される: `f( (v[i], ++i) )` (`f(v[i], ++i)`とした場合の動作は定義されない)
- `一時オブジェクト（temporary）`: コンパイラが中間結果を保持するために導入するオブジェクト. `v = x+y*z` のうち `y*z`の計算結果を一時オブジェクトに置いておき、後から x との演算に利用
  - 一時オブジェクトは`完全式(full expression)` が評価された後に完全に解体（解放）される. そのため思わぬ挙動を生む可能性がある. 一時オブジェクトへの参照を取得しようとする実装をしないようにする. 例えば、`const char* cs = (string1 + string2).c_str();` は動作しない
  - 一時オブジェクトは `const の参照`や`名前付きオブジェクトの初期菓子`として利用できる。この場合一時オブジェクトはそのオブジェクトがスコープから抜けて解体される時に一緒に解体される
  - `局所変数への参照を返すのは誤りである`ことと`一時オブジェクトは 非 const 左辺値参照にバインドできない`ことを覚えておく(271)
  - `式の中で明示的にコンストラクタを呼ぶと一時オブジェクトが生成される`(`s.move(string(n, ch))` → string コンストラクタを呼び出して直接 move に渡す → 一時オブジェクトが作成される)
- `縮小変換(narrowing conversion)` せざるをえない場合は、`narrow_cast<>()` の利用を検討
- `特殊化(specialization)`: テンプレートはデフォルトでたった一つの定義でユーザーがから考えられるあらゆるテンプレート引数（あるいはその組み合わせ）で利用できるようになる. しかし、このことは、テンプレート開発者にとって必ずしも理にかなっていることではない. "テンプレート引数がポインタだったら、こちらの実装を利用して、ポインタでなければあちらの実装を利用する"など、設計上の問題の多くは、テンプレートの大体実装をあらかじめ定義しておき、実際の利用時に与えられたテンプレート引数に基づいて、コンパイラに選択させることで解決できる。`テンプレートのこのような大体実装は`、`ユーザ定義特殊化(user-defined specialization)` または単に`ユーザ特殊化(user specialization)`と呼ばれる.(730)
- 名前付きオブジェクトの生存期間はスコープが決定するが、スコープに依存せずに生存可能なオブジェクトを作成すると役立つことも多い。例えば、関数の返却値として名前付きオブジェクトの参照を返す時などである（この際は返却先で delete で解体する）。ただ返却値として利用するために new を使うのではなく、move を使って所有権を移動させることで所有者がスコープを抜けた時に自動で解体されるようにする方が object leak を防ぐには better(288)

  - そのための機構 `new`（によってメモリを割り当てる）であり、それを解体するのが `delete` である. (`空き容量 (free store) 上にある`、`ヒープ(heap) 上にある`、 `動的メモリ(dynamic memory) の中にある`、ともいう.)
  - `局所変数(local variable)`（関数内で宣言する変数）で`裸の new 演算子`は避ける（unique_pointer などでラップする）
    - `delete[]` で解体できるのは、`new で確保した配列をさすポインタ`か、あるいは、`空ポインタ`であり、空ポインタの場合は何もしない.

- `配置構文(placement syntax)`: new では空領域にメモリを確保するが、特定のアドレスに割り当てることもできる. この場合、new にそのアドレスを void* 型にキャストして渡す(`reinterpret_cast<void*>(0xF00F)`) この時確保されるオブジェクトの大きさは暗黙裏に決定される
- `nothrow new`: `new(nothrow) int[n]` のように `nothrow` を引数に渡すと、`bac_alloc 例外`が送出されずに `nullptr` が返却されるようになる
- `並び`: `{} 構文` 型修飾される場合その型で初期化を行う. 型修飾されていない場合は利用されている文脈に応じて型決定を行う.
  - `修飾並び`: S{..} のように型修飾されている並び(`S v{7,8}; // 変数の直接初期化 v = S{8,9}; // 修飾並びによる代入`)
  - `非修飾並び`: {} のように型修飾されてない並び(`int v{1} // 変数の直接初期化 v = {2}; // 非修飾並びによる代入`)
- `ラムダ`: 関数オブジェクトを定義する簡略法
  - `ラムダ`を用いる時は呼び出す川の生存期間よりも長くなる可能性がある場合は、参照としてキャプチャするかどうか慎重に判断する
  - `ラムダ`内でも名前空間内の名前を利用できるので、わざわざキャプチャする必要があるかどうか確認すること
- `関数`:
  - `引数の受け渡し`:
    - 関数名の後ろに置く`()`は`呼び出し演算子（call operator）`または、`アプリケーション演算子(application operator)` と呼ばれる
    - 関数を呼び出すと、関数の`仮引数（formal argument、またはパラメータ（parameter））`のためのメモリ領域が割り当てられ、個々の`仮引数`が対応する`実引数`によって初期化される
    - 引数に pointer を渡しても元のオブジェクトは変化しない（変更できるのは参照で渡されたオブジェクトのみ）. もし pointer の指すオブジェクトを変更したい場合は、参照で渡す(`void foo(type *&in) {...}`)
  - 関数に渡す引数は明示的に型変換される(`double sqrt(double); sqrt(2);` とすると暗黙裏に `sqrt(double{2})` なり型変換される)(313)
  - 行列などでは入れ子のループには内積を用いると良い
  - 関数にバグが忍び込むのは、アルゴリズムの一部しか確認できないような時であるので、約 40 行を関数の上限とするようにする（ビャーネストラウストラップは 7 行を理想としている）
  - 関数の呼び出しがコストになることはあまりない。もし問題となる場合は、`インライン化`すればコストを削減できる
  - 関数宣言の構成要素(315):
    - `inline`: 関数呼び出し箇所に、関数本体を埋め込んで欲しいということを表す
      - `相互再帰`や`再起呼出し`を行うかどうかが、与えられた値に依存する関数などがインライン関数となることもあるため、インラインに必ず展開されるという保証はない(319)
    - `constexpr`: `関数の引数が定数式である場合`に、関数評価がコンパイル時に可能であることを表す
    - `noexcept`: `関数が例外を送出しないことを表す`
    - `[[noreturn]]`: 通常の呼び出し・リターンの機構下でも、`関数がリターンしないことを表す`
    - `結合指定`: 例えば `static` など
  - 引数:
    - `関数宣言`の引数は省略可能で、その引数名と`関数定義（関数本体を伴う関数宣言）`の引数名は違っていても良い
  - 関数定義の引数に名前を与えなくても良いが、その場合その引数を使用しないことを表す（コードの単純化や将来の拡張のために使う）
  - 後置形式の返却型を使う重要な用途が、引数に依存する返却型を持つ関数テンプレート宣言におけるものである. (`auto product(const vector<T>& x, const vector<U>& y) -> decltype(x*y)`)
  - main 関数を除いて、void 以外は必ず値を返さないといけない
  - 関数が値を返却するセマンティクス（`return`）は、引数受け渡しの背マンティクスと同様にコピー初期化と同じ。そのため、返却型の変数を初期化し、暗黙裏に型の変換が行われる (`double f() {return 1;} // 1 は double{1}`)(317)
  - コマンドライン引数を処理する場合は、伝統的な C スタイルの手法ではなく、コンテナを使った手法を取り入れる.
  - デフォルト引数を積極的に取り入れることでメンバ関数の記述量を圧倒的に軽減・保守性を高めることができる
- `One Definition Rule`: objects and non-inline functions cannot have more than one definition in the entire program and template and types cannot have more than one definition by translation unit.[Ref](https://en.wikipedia.org/wiki/One_Definition_Rule)
- `多重定義(overloading)`:
  - 同じ関数名で異なる別々の引数型に対して別々の処理を実装する（コンパイラが仮引数と実引数の型を比較して関数を`自動解決`する、また`返却型`は考慮されない）:
    - 関数の宣言順序は無関係
    - コンパイラは引数の一致度が一番高い関数を選択する（次のような場合は、優先度が同一の関数が複数あるためエラーとなる: `f(double, double); f(int, int); void main(){ f(2.0, 2); }`）
    - `Multi dispatch（複数の引数の自動解決）` をサポートする
    - 一致する関数がなければコンパイルエラーとなる
    - 詳細な自動解決の詳細は(334)を参照
  - テンプレートは多重定義された関数を一括りにする体型的方法を提供する:
    - `関数テンプレート`は、`引数一式に対する特殊化の結果に対して多重定義解決規則を適用することによって処理される`(335)
    - `{} 並びを使った場合の多重定義(初期化子並びが優先される)`と、`テンプレートの右辺値参照引数`には、別の規則が適用される(335)
  - 継承による同名関数の定義は多重定義にはならない.
    - `クラススコープや名前空間をまたがる多重定義`が必要であれば、`using 宣言`や `sing 指令`を用いる.
    - `実引数依存探索`を用いると名前空間をまたがる多重定義が可能
  - `多重定義`のメリット:
    - 関数の呼び出しの際に行われる引数の型変換のうちエラーに繋がりやすい`縮小変換`が起きるのを防ぐ（多重定義による変換では、`標準変換`が行われるのぜより安全な変換になる(334)）
  - 手動による解決:
    - `static_cast<int *>(0)` のように明示的型変換を用いる方法もあるが、このような一時凌ぎでは呼び出す箇所全て同じようにしないといけなくなってしまう
  - `事前条件`と`事後条件`(338):
    - 関数を呼び出した時に、引数の型はコンパイラやリンカが保証するが、実際に入ってくる値が不正な値に対処するのはプログラマの責任である.
    - `事前条件(precondition)`: 関数が呼び出された時点で保証されるべき論理的な規則
    - `事後条件(postcondition)`: 関数がリターンした時点で保証されるべき論理的な規則
    - 関数が非局所オブジェクトを利用・変更する場合は、その影響を考慮してドキュメント化しなければならない
  - `関数へのポインタ`:
    - `多重定義`された関数へのポインタを取り出す際には、関数の型(引数型と返却型)が使われる
    - `noexcept` 関数を指すポインタは、`noexcept` と宣言しても良い
    - `関数の結合`を反映したものでないといけない(343). `型別名(using)`の宣言では、`結合指定`と `noexcept 指定`は行えない(343).
    - `関数を指すポインタ`よりも、`関数オブジェクト（ラムダを含む）`や`仮想関数`を優先する
- `マクロ`:
  - マクロの利用で有用なのは`条件コンパイル`である.
  - いくつか定義済みマクロで有用なものがある. `__func__`, `__TIME__`, `__FILE__`, `__LINE__` あたりは便利.
- `エラー処理`:
  - `terminate()`: うまく機能するフォールトトレラントシステムは、数段階のレベルを持つ. 各レベルでは、ねじれを発生させすぎない範囲でできるだけ多くのエラーを処理して、対処できないエラーを上位のレベルへ渡す構造であり、この構造をサポートするのが `terminate()` である. これを使うと、`例外処理システム自体が壊れている`、あるいは、`不完全にしか動作しない`、などの理由によって例外が捕捉されないままとなった状態からの脱出が可能.
    - terminate が呼ばれる条件:
      - exception が捕捉されない場合. 換言すると、送出された例外に適したハンドラがない時 (it is implementation-defined whether any stack unwinding is done in this case)
      - `noexcept` が例外を行って終了しようとした時
      - exception をハンドル中に exception が捕捉されずに抜けてしまった際に、exception ハンドルメカニズムが使う(e.g. a destructor of some local object, or a copy constructor constructing a catch-clause parameter)
      - `スタック巻き戻し中`にデストラクタが `throw` を行って終了しようとした時
      - throw する例外がない（catch 節の外）のに再送出した時
      - a static or thread-local object のコンストラクタ（初期菓子）が exception を投げたとき
      - `std::atexit` or `std::at_quick_exit` で登録された関数が exception を投げたとき、など. 詳細は p381 を参照(381)
  - `noexcept`:　エラー回復が不可能と判断される場合に、エラー処理から脱出できる
  - `例外安全なコード`: あるコード内で実行中の失敗が、`メモリリーク`、`格納データの不整合`、`不正な出力`などの有害な効果を生じないこと
  - `資源獲得時初期化(Resource Acquisition Is Initialization: RALL)`: 局所オブジェクトを使った資源管理のこと(366), 具体的には、資源の'取得'を`クラス型変数の構築`（`初期化`）時に、また'返却'を`破壊時`に行う。特にプログラムの制御フローが`自動変数の属するブロックを抜けるとき`、その変数のデストラクタが自動的に呼ばれるため、デストラクタを適切に記述したクラス型変数の寿命が終わるとすぐに資源が返却されることが保証できるようになる。これは例外が発生したときでも同様
    - 資源管理には、`try-except`を使うのではなく、コンストラクタで資源を確保しデストラクタで確実に解放する`資源ハンドル`をすること
    - コンストラクタの途中で問題があった場合、部分オブジェクト(問題発生までに作成されたオブジェクト、完全オブジェクトではない)はデストラクタで確実に解体すること（`作成途中`の状態に置かないこと）
    - `二つ以上の資源`：この場合も、同様な方針でコンストラクタで資源獲得を行い、どちらか一方でも失敗した場合は `throw` するような仕組みで構築すると良い
  - デストラクタで例外を送出してはいけない.(372)
  - 捕捉した例外オブジェクトは、送出された例外オブジェクトのコピーである。すなわち、throw x; では、x 型の一時オブジェクトが　 x で初期化される。その一時オブジェクトは、捕捉されるまでに複数回コピーされることがある(373)
  - `スタック巻き戻し（stack unwinding）`: 送出された位置からハンドラまで、例外を`スタックの上方`へ渡す過程:
    - 構築されたオブジェクトは、スコープを抜けた時に解体される。また`スタック巻き戻しの過程で構築されたオブジェクト`は`作成された順の反対の順`で解体される
  - H から継承した Exception E の場合、H は`公開基底`という。この場合、E を `throw` した際には `catch(H) 節` で拾われる. 同じ条件下でそれぞれの型がポインター、または参照型でも実行される(376)
  - 例外に const を不可することもできて意味自体変化しないが、その例外自体を変更できなくなることを示すために使われる
  - `再送出（rethrow）`: catch 節以外の場所でやると `terminate()`. 再送出されるのは、catch された内容で、例え exception などの公開基底で catch しても元の例外が送出される. もし別の例外を送出したい場合は、throw My_error{} のように例外をつけて throw する. このように再送出の際に例の内容が変わることを`スライシング`という. スライシングを行うと、上方では元の例外を catch することができなくなる
  - 関数全体を try-catch にするメリット: コンストラクタでメンバの初期化に失敗した場合に、呼び出したところに throw するのではなく catch できる。ただ初期化しようとしたメンバオブジェクトが未構築であれば構築されることはないし、もし構築済みであればスタック巻き戻しの一環でデストラクタによって解体される。結局は最後に再送出することになる
  - 名前空間とスレッド局所変数の構築中あるいは解体中に送出された例外を捕捉する方法は存在しない. このことは広域変数を避けるべき理由のひとつである. (383)
  - あるスレッドが送出した例外を他のスレッドのハンドラに転送する処理は、標準ライブラリ関数 `current_exception()` によって行う
- `template`:

  - The difference between `typename` and `class`: in general no difference. typename is clearer to indicate it's type, not object.
  - [nested template1](https://stackoverflow.com/questions/20373466/nested-c-template-parameters-for-functions)
  - [nested template2](https://stackoverflow.com/questions/39078287/nested-templates-template-template-parameters)

- `allocator`: explicitly `allocate heap memory`, construct it, destroy it, and then finally deallocate the memory. (If you don't want to do that, don't use an allocator, use new instead.)

  - `you use an allocator when an allocator is required` (such as when using a container) and you use `std::allocator when you don't want to provide a custom allocator` and just want the standard one. You don't use an allocator as a replacement for `new` and `delete`.
  - `new` または `malloc` を使用すると、`メモリ管理`は`コンパイラのランタイムの対応する関数に固定`されるが、`アロケーター`が使用される場合、`メモリー管理`は`アロケーターに委任され、アロケーターは交換可能`である。これにより、使用するメモリ管理機能を変更することができる。
  - vector などの初期化した時に確保したメモリをその時点で全て使用するのではなく、将来のどのタイミングかで利用する時などに有効.
  - vector の場合、`reserve` すると初期化の時点で capacity をセットできるため、reallocation が問題であればこちらを使う.
  - vector は保持できるサイズ（`vector::max_size`）を超えると `length_error` を送出する `my_vector.max_size()` で確認する（基本的には膨大な値）
  - [Ref1](https://stackoverflow.com/questions/31358804/whats-the-advantage-of-using-stdallocator-instead-of-new-in-c)
  - [Ref2](https://cloud6.net/so/c%2B%2B/1348832)

- `explicit`:
  - Prefixing the `explicit` keyword to the constructor prevents the compiler from using that constructor for implicit conversions.
  - [Ref](https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean)
  - Compiler can use `constructors callable` with a `single parameter` to convert from one type to another in order to get the right type for a parameter.
  - `Single parameter` でなくても、`先頭の仮引数以外の仮引数にデフォルト値が渡されていている場合`も、`Single parameter` とみなされるため、`implicit conversion` が適用される. 例) `Object( const char* name=NULL, int otype=0).`
- `名前空間（namespace）`:
  - 名前空間内で宣言されている実体は、`名前空間のメンバ`と呼ばれる
  - `明示的修飾`: メンバを利用するときは、`完全修飾子`を使う: `namespace Text_lib{ class Graph { /* ... */}}` の時に Graph を使うときは `Text_lib::Graph`(400)
  - `using 指令`、`実引数依存探索`: namespace の外からある名前空間のメンバを利用する方法:
    - `using`:
      - `広域スコープ`はそれ自体が名前空間になる. `::` を使うと明示的に`広域スコープ`を参照
      - `using 宣言`: 同義語（ある名前空間のメンバ）を同じスコープ中に導入する(`using N::f;`). 多重定義や名前衝突が起こる可能性があるため、なるべく局所的に使う
        - class 内で `using` を使う手法もある(595)
      - `using 指令`: ある名前空間のメンバを全て同スコープ中に導入する(`using namespace std;`).
    - `実引数依存探索（argument-dependent lookup/ ADL）`(403):
      - 関数 C 内で呼ばれるある関数 F が同一スコープに見つからない場合、関数 C の実引数自体の名前空間が探索の対象となること。
      - その結果同じ関数名が複数見つかった場合: 通常の多重定義解決が行われる
        - この関数の探索は、`（通常通り）関数呼び出しのスコープ`、`全引数（クラスと、その基底クラス）の名前空間`から行われる
        - 一致度が一番高いものが選択されるため、期待してる関数が呼び出されないことがある. 例えば同クラスに同じ関数を定義しそれが呼び出されることを期待しているが、別の`関連名前空間`に定義されている同名の関数の方が引数の一致度が高く、そちらが呼ばれる可能性がある.
      - `関連名前空間(associated namespace)`: `実引数依存探索の規則`(404)
        - 引数がクラスメンバであれば、`関連名前空間`は、そのクラス自身（とその基底クラス）とそのクラスを囲む名前空間
        - 引数が名前空間のメンバであれば、`関連名前空間`は、そのメンバを囲む名前空間
  - 名前空間によってインターフェースと実装を分離する。さらにその場合、namespace 名は同じである必要はないため、`ユーザー用インターフェース`と`実装者用インターフェース`を分離すると良い(412)
  - `同名変数の衝突`:
    - `局所的に宣言された名前`（それが`通常に宣言されたもの`でも、あるいは、`using 宣言で宣言されたもの`であっても）は、同じ名前の非局所の宣言を隠す.(413)
    - 尚、上のように`局所的な宣言`を複数回行うことは不正である
    - また`非局所的な変数`が複数個あると曖昧エラーになる（広域と using 指令によって複数候補存在する場合など）
    - 上記の規則をうまく活用すると、合成(using 指令)と選択(using 宣言)によって宣言に必要な柔軟性を手に入れることができる(415). つまり、合成しつつもし名前で衝突した場合は、選択によって局所的に宣言して衝突を回避することができる. これによってさまざまな名前空間を組み合わせることが可能となる.
  - `名前空間別名`: 同じ名前空間に対して、型別名をつけられるのでバージョン管理が容易になる(414)
  - `インライン名前空間(inline namespace)` を使うことによって複数のバージョンを管理することができる(418)
- `コンパイル`:

  - `外部結合（external linkage）`: 定義した名前が別の翻訳単位でも利用可能であること
  - `内部結合（internal linkage）`: 定義した名前が翻訳単位内のみでも利用可能であること
    - `static` をつけると内部結合になり、`const`の変数は暗黙裏に内部結合になる. `const` を外部結合にする場合は、明示的に `extern` をつける.
  - `無結合（no linkage）`: リンカから見えない局所変数など
  - `inline 関数`の整合性を保証したい場合は、ヘッダを利用する（ヘッダに書いて使うところで読み込む）(428)
  - const オブジェクト、constexpr オブジェクト、型別名、名前空間スコープ内で static と宣言されたものは全てデフォルトで内部結合. そのためこれらを外部結合にしたい場合は、inline 関数と同様にヘッダに extern と宣言することで整合性保証と可読性を保つ.(428)
  - `ファイル内局所名`: `static` とするか、`名前無し名前空間`で宣言する(429)
    - `名前無し名前空間` とするとコンパイル単位だけの局所的なものとすることができる.
  - ヘッダに定義するべきものとすべきでないもの(431):
    - 定義するべきもの: `名前付き名前空間`、inline 名前空間、テンプレート宣言、テンプレート定義、型定義、など
    - すべきでないもの: 通常の関数定義、データの定義、集成体の定義（`short tbl[] = {1, 2, 3}`）など
  - `単一定義則（one-definition rule/ ODR）`: クラス、列挙体、テンプレートなどはプログラム内でちょうど１回だけ定義されなければならないこと
    - 別々のファイル（`異なる翻訳単位である`という）でも定義が全く同じであれば（`トークン単位で同一である`という）二重定義は問題ないが、通常は２回以上定義すると、一方のみ参照しているプログラマによって一方の定義のみ修正される可能性が出てくるのでヘッダで管理すること.
  - `C 結合`: C++ 以外のコードとの結合を分けるために使われる. `C 結合`の場合は C 言語に限らず Fortran やアセンブラルーチンに対して用いられることもある.(435)
    - `extern "C" ...`のように宣言する.
    - 結合同士の関数などの利用はできるが、言語を超える利用は基本的にはできない(言語拡張機能として認められるなどでエラーにならない場合もある)(436)

- `class`:
  - `物理的定数性`と`論理的定数性`(466):
    - `論理的定数性`: 論理的には const であるはずのメンバ関数が、データメンバの値を変更する必要に迫られることがある。その場合、ユーザには、オブジェクトの状態が変化しないように見える一方で、ユーザからは直接見えない細部が変更される
      - このような場合に `mutable` で修飾したデータメンバを変更することができる
      - または、変更される可能性があるオブジェクトを別オブジェクト内に置いた上で間接的に利用することもできる(467)
  - `自己参照`:
    - `this` は右辺値とみなされるため、アドレスを取り出したり、代入の対象にしたりすることは不可能である.
    - `非 static メンバの参照`は全て、適切なオブジェクトを得るために`暗黙裏に this を使用して呼び出されている`（これはオブジェクトがポインタである場合も暗黙裏に呼び出されている(`this->` が呼び出されている)）.(468)
    - `テンプレートである基底クラスのメンバ`を`派生クラスから利用する際`には、明示的に `this` を利用する必要がある.(469)
    - 特定のクラスのメンバを直接利用するときは `::` を使う. (`int (S::*) pmf() {&S::f};` 関数へのポインタをこのように表すこともできる)(470)
    - `static データメンバ`はクラス全体で１個だけ存在する。同様に `static メンバ関数`は特定のオブジェクトに対して呼び出す必要がない関数である
      - `static データメンバ` は競合が起こす可能性がある場合は、ロックなどのアクセス規則が必要である.
    - `入れ子クラス（nested class）, メンバクラス（member class）`: クラスの中に定義されるクラスであり、メンバクラスはそれを囲んでいる型と方が持つ static なメンバ、非 static なメンバ(private メンバも含めて)を利用することができる.(472)
      - 囲っているクラスからクラスメンバのメンバを参照することはできない.
      - クラスメンバから囲っているメンバを参照する場合は、引数にポインタで渡すとよい.(472)
  - `具象クラス`:
    - クラス設計も含め、そもそも設計とは、何らかの決断を下すものであり、決断を先延ばしにしたり、あらゆることをオプションとしてユーザに押し付けるものではない(476)
    - コンストラクタがクラスの不変条件を確立する。一旦オブジェクトが作成されるとそれは正当なオブジェクトとして利用できることを保証する(476)
    - メンバ関数はこの不変条件を維持するように努めなければならない
    - `ヘルパ関数`: 内部表現に直接関与しない関数はメンバ関数とせずに、ヘルパ関数とするとこでクラスインターフェースを簡潔化させることができる
    - Date のような`単純なユーザ定義型`を`具象型（concrete type）`と呼ぶ。`具象クラス`は、`組み込み型と同等`で、`値型（value type）`とも呼ばれ、それを利用したものは`値指向プログラミング（value-oriented programming）`と呼ばれる。これは、一般にオブジェクト指向プログラミング（object-oriented programming）とはまったく異なる.(480)
      - `具象型の目的`: 比較的単純な単一の処理を、効率よく的確に実行すること.(480)
      - 具象クラスからの派生では、仮想関数や実行時型情報が利用できないため、限られて場所で注意深く使うべきである(481)
  - `配置構文(placement syntax)`: 割り振られたス トレージ・ロケーションを指定して、そのストレージ（メモリ領域）にオブジェクトを作成する（new）方法(292)
    - [Ref](https://www.ibm.com/docs/ja/xl-c-and-cpp-aix/13.1.0?topic=only-placement-syntax)
  - `private な destructor`: スコープを抜けた時や delete された時に暗黙裏に destructor が呼ばれるが、この挙動を抑制する方法として、destructor を private に宣言することである(490)
  - `virtual な destructor`: 一般に仮想関数を持つクラスでは、デストラクタも virtual にするべきである. これは、基底クラスのインターフェースを通じて操作されるオブジェクトが、基底クラスのインターフェースを通じて delete されてしまう可能性があるため. 基底クラスのデストラクタが virtual でない場合、派生クラスのデストラクタが delete によって起動できなくなるため、削除したいオブジェクトがリークしてしまう.
  - `コンストラクタがない場合の初期化(struct)`: 初期化しない場合（`{}`, などでコンストラクタを呼び出さない場合）局所変数や秋領域に割り当てられたオブジェクトでは、クラス型のメンバのみがデフォルト初期化されて、組み込み型のメンバは初期化されない.(492) 例えば `struct Buf{ int count; char buf[16 * 1024]}; Buf buf1; Buf buf2;` では、buf1 は初期化されないので、局所変数は不定値（0 などではない）であるが、buf2 ではちゃんと初期化される.
  - vector などのコンテナを利用する場合で、値と個数の型が同じ場合（値が int の場合）や 0 を用いる場合の挙動はやや直感からはズレるため注意する(495) `vector<int *> v6 {0, 0}; // nullptr で初期化される 2 要素の vector`
  - 参照と const は初期化が必須である
  - 複数のコンストラクタが存在する場合には、`デフォルトのコンストラクタ`、その次に`初期化子並びコンストラクタ`が優先的に呼び出される(498)
  - 初期化子並びは変更できないし、ムーブコンストラクタに適用もできない. そのため、初期化子並びを書き換え等の初期値として利用したいときは、コピーする(`uninitialized_copy(s.begin(), s.end(), elem);`)(500)
  - `コピー初期化(copy initialization)`・`直接代入(direct initialization)`を区別する. よく利用されるコピー初期化では暗黙裏に型変換を行っている(`int a = {1};`) 一方で、直接代入では型変換は行っていない(`int a{1};`) この違いは explicit を用いることで顕著化する.(462)
    - また例えば、`vector<int> v = 1;` は暗黙裏に型変換を行おうとするが、`int -> vector<int>`の変換は存在しないのでエラーになるのに対し、`vector<int>{1};` は 1 を initializer_list の１要素として初期化を行うため問題ない。（また、vector などの複数の要素を受け取るコンテナの場合 `vector<int>(2)` とすると`デフォルトが 0 の 2 要素のメモリ確保`の意味になるため注意.）
  - クラスにデフォルトコンストラクタを与えるのは、`自然な`デフォルト値が存在する場合に限定する(527)
  - `メンバのコンストラクタ`:
    - クラス自身のコンストラクタ本体の実行前に呼び出される.
    - メンバの呼び出しの順序は、初期化子に記述した順序ではなく、クラス内でメンバを宣言した順序になる.
  - `メンバのデストラクタ`:
    - クラス自身のデストラクタ本体の実行後に呼び出される.(コンストラクタと逆)
  - コンストラクタは、メンバの基底、メンバのメンバ、基底のメンバ、規定の規定などの初期化は行えない(502)
  - `初期化子による初期化`と`代入による初期化`の両方を行うことができる
    - `代入による初期化`では、いったんメンバをその型で初期化した後で引数を代入することで初期化される(503)
  - `基底クラス`:
    - 基底クラスの初期化はメンバより先に初期化されてメンバの後で解体される.
  - `委譲コンストラクタ（delegating constructor）/ 転送コンストラクタ（forwarding constructor）`: 複数コンストラクタを宣言し、メインのコンストラクタに処理を委譲するような他のコンストラクタのこと(504)
  - `クラス内初期化子`: 複数コンストラクタで初期化するクラスのメンバであれば、局所的に初期化をすることができる. (506)
  - `クラス宣言内で static メンバの初期化は基本的にはできない`が、`const な汎整数型`あるいは`列挙体`、または、`constexpr なリテラル型`であれば初期化可能である. (507)
  - `基底のコピー`: `コピー演算においては基底は単なるメンバにすぎない`. コピー演算では全メンバをコピーする必要があるため、派生クラスのオブジェクトのコピーではその基底もコピーする必要がある.
    - 基底をコピーするには引数に渡された派生クラスのオブジェクトで基底クラスの初期化をすれば良い. (511)
  - `浅いコピー`: コピーオンライトと `shared_ptr` を上手く使うと効率の良いコピーを実装することができる(514)
  - `スライシング`: `派生クラスを指すポインタ`は、その`公開基底クラスへのポインタ`へと暗黙裏に変換されること
    - スライシングされた時には、派生クラスのメンバは利用できなくなり（アクセスできなくなり）、公開基底クラスをしかアクセスできなくなる.
    - スライシングを防ぐ 3 つの方法:
      - 基底クラスのコピー禁止: コピー演算を `delete`. その代わり、close() 関数が必要になるかもしれない (17.6.4)
        - `関数の delete`を利用する他の目的(525):
          - 例えば、クラスをメモリ上に割り付けられることの制御として使用. (この場合、デストラクタを`=delete`すると、"解体できないオブジェクトは空き領域に割り当てられない"ためインスタンス化できなくなる. ただし new で作成することはできる(17.2.2))
      - 派生へのポインタを基底へのポインタへ変換できなくする: 規定クラスを private もしくは protected にする (20.5)
      - コピー演算を private, protected と宣言した上で、スライシングを伴わないコピーが可能となるように close() 関数を実装する (20.3.6)
  - `デフォルト演算の生成の規則`:
    1. プログラマがクラスのコンストラクタを１個でも宣言すれば、コンパイラはデフォルトコンストラクタを生成しない
    2. プログラマがコピー演算、ムーブ演算、デストラクタのどれか１個でも宣言すれば、コンパイラはコピー演算、ムーブ演算、デストラクタを一切生成しない
    - しかし、後方互換性維持のため`デストラクタを作成してもコピー演算、ムーブ演算が生成されてしまう`(519)
  - `明示的な default`: `=default` とすることで、コンパイラが自動で生成する演算をデフォルトとして使用することを明示的に示すことができるが、挙動は等価で単に冗長的であるので避ける方が良い
  - `メンバにポインタを持つ場合`: 危険である
    - 複数のオブジェクトが同じポインタの場合、デフォルトのデストラクタはメンバのポインタを二重に delete してしまう可能性がある(523)
  - `メンバを指すポインタのメンバを持つ場合`: 危険である
    - そのオブジェクトを move した時には、ポインタを指すメンバのアドレスは変わるため（関数から返した時、初期化した時のポインタのアドレスが move によって変わる）古いアドレスを指しているメンバは新メンバがいるアドレスとは別のアドレスを指すこととなる(522)
  - クラスが仮想関数を持つのであれば、仮想デストラクタも必要である.
- `演算子(演算子関数)の多重定義`:
  - 新しい演算子トークンは定義できない. 定義できる演算子は 531 を参照.
  - `operator ""()`: ユーザ定義リテラルが定義
  - `operator T()`: 型 T への型変換を定義
  - 演算子を利用するのは、明示的な演算子関数呼び出しの省略形にすぎない `void f(complex a, complex b) { return a + b; } // 省略形` `void f(complex a, complex b) { return a.operator+(b); } // 明示的に呼び出す`
  - `二項演算子`: `@` を演算子とすると、`aa@bb` は `aa.operator@(bb)` または、`operator@(aa, bb)` のいずれかに解釈される
    - 両方定義したときは`多重定義解決法則`によって解決される(532)
  - `単行演算子`:
    - 前置単行演算子を `@` を演算子とすると、`@aa` は `aa.operator@()` あるいは、`operator@(aa)` と解釈される
    - 後置単行演算子を `@` を演算子とすると、`aa@` は `aa.operator@(int)` あるいは、`operator@(aa, int)` と解釈される
  - `演算子の探索`: 二項演算子が `@`であり、`x` が `X` 型オブジェクト、`y` が `Y` 型オブジェクトであるとき、式 `x@y` は次のように解釈される(536):
    - 演算子の探索において、メンバが非メンバより優先されるということはないし、広域の演算子関数が局所関数によって隠れてしまうということはない(537)
    1. X がクラスならば、X のメンバとしての `operator@`、あるいは、X の基底のメンバとしての `operator@ `を探索
    2. `x@y`を囲む文脈の中で、`operator@` の宣言を探索
    3. X が名前空間 N で定義されていれば、`N` 内で `operator@` を探索
    4. Y が名前空間 M で定義されていれば、`M` 内で `operator@` を探索
- `メンバにするか、非メンバにするか`:
  - 第一引数の値を変更するような演算子はメンバ(+=): `内部表現へのアクセスが必要となるため`
  - 引数を元にして別の値を作るだけのような演算子は非メンバ(+)
- `混合算術演算（mixed-mode arithmetic）(Fortran の定義による)`: z が `complex` であるときに `2+z` を正しく扱うためには、`+演算子`が左右の型が異なるオペランドを受け付ける定義が必要である. (539)
- `混合算術演算で発生する組み合わせの数の爆発的増加を封じ込める方法`: 暗黙的な型変換を利用する. 引数型と適用可能な変換（`標準型変換`と`ユーザ定義型変換`）(541)
- `ユーザ定義リテラル`: 例えば`constexpr complex<double> operator "" i(long double d)` のように `i` に対してリテラルを定義すると `12e2i` が 1200 を虚部として持つ complex オブジェクトに変換することができる(543)
- ユーザ定義型の暗黙の変換は、１段階のみが認められている(547)
- 型変換に複数の候補が存在する場合、組み込みの型へ変換変換できる場合は、ユーザ定義型に優先して採用される(548)
- `特殊な演算子`:
  - アロー演算子(`->`)は多重定義できるが、ドット演算子(`.`)はできない(556)
  - アロー演算子の返却値は、ポインタであるか ` ->` が適用可能なクラスでないといけない(556)
  - インクリメント、ディクリメント：前置・後置の区別(557)
    - 前置: インクリメントの実装の場合、ダミー引数を持たずに参照を返す++ すなわち `int& operator++()` 
    - 後置: 後置であるダミー引数を持ち演算結果前の古い値を値渡しで返す++ すなわち `int operator++(int)` 
  - `テンプレートリテラル演算子(template literal operator)`: 関数ではなく、テンプレートパラメータパックを引数に受け取るリテラル演算子(561)
- `フレンド(friend)`: 他のクラスの内部要素にアクセスすることができる
  - フレンド関数は他のクラスのメンバ関数でも可能. `friend int* List_interator::next()`(573)
  - あるクラスの全てのメンバ関数を別のクラスのフレンドとするための省略記法もある `friend class List_iterator;`
  - PHP の trait のような感覚で利用できる. 
  - テンプレート引数を friend にすることもできるため、必要に応じて利用するメンバ関数を切り替えることができる `friend T; // class を T の前につける必要はない` (574)
  - `フレンドの探索`: 
    1. 同一スコープ内で、事前に宣言
    2. friend を宣言するクラスがいるスコープの外で宣言（事前に宣言する必要がない）
    3. 一番内側のスコープ外は事前に宣言する必要がないが、それよりも広域のスコープ（２スコープ以上外）の場合は、やはり事前に宣言しておく必要がある
    4. スコープ内場合でも、フレンド関数を持つクラスのインスタンスを引数にとることで、インスタンス経由でフレンド関数を探索することができる(引数に何も取らないフレンド関数の場合は探索しようがないためエラー) (575)
- `引数の変換`:
  - `非 const 参照引数`が暗黙裏に変換されることはない (-> 非 const なので、参照先のオブジェクトを変更することを期待している) -> `メンバ関数`とすべき（演算子 = *= ++）
  - `const の参照`, `値渡しの引数(非参照引数)`は暗黙裏に変換される -> 暗黙裏に型変換を期待する関数は、`非メンバ関数`とすべき (演算子 + - ||）(576)
   - 演算子 + - || は内部表現にアクセスする必要がでてくることも多く、その場合に friend とする
  
- `継承`:
  - `主な手法`:
    - `インターフェース継承`：`実行時多相性（run-time polymorphism）`, `動的多相性（dynamic polymorphism）`と呼ばれる
      - メンバ関数に virtual をつけることで実現する
      - オブジェクトのアクセスにポインタや参照経由で直接アクセスするときは、コンパイラは型がわかっているため`実行時多相性（run-time polymorphism）`は不要である(virtual を付けずに単に規定クラスの関数をオーバライドするだけで良い)
      - コンストラクタやデストラクタの中で仮想関数を使用は避けるべきである:
        - 部分的に構築、解体された状態だと想定している仮想関数が呼ばれない可能性があるため.
    - `テンプレート`: `コンパイル時多相性（compile-time polymorphism）`、`静的多相性（static polymorphism）` と呼ばれる
  - 派生クラスのオブジェクトは、ポインタと参照を経由して利用された場合にその基底クラスのオブジェクトとして処理される. ただしその逆は成立しない(582)
  - 派生クラスは規定クラスの private にアクセスできない：
    - メンバ関数、フレンド関数を見るだけで内部表現がどのように操作されているか把握できるようにするため.
    - プログラマはクラスを継承するだけで内部表現にアクセスできてしまうため
  - どうしてもアクセスが必要であれば、限定公開メンバとして宣言する
  - 基底クラスのメンバにアクセスする場合は、`規定クラス名::member` とする `Base::print()`:
    - `::`: スコープ解決演算子
  - `継承を最大限に活用する`: ポインタ型を与えられたときにそれがどの派生クラスを指すのかを明確にできるようにする:（585）
    1. ポインタが指す型を、ある単一型のオブジェクトに限定する
    2. 関数が判断できるように、規定クラス型フィールドを持たせる
    3. `dynamic_cast` を利用する
    4. 仮想関数を利用する
  - `型フィールド`を用いることの問題(586)：
    - 基底クラスが持つ公開関数が派生クラスが増えるごとに、また機能が増えるごとに無限に肥大化してしまうため、変更箇所が広域になってしまうかつテストするためのオーバーヘッドが避けられなくなる.
    - 型フィールドを使う場合、派生クラスを追加するごとに派生クラスのための型を型フィールドの追加する必要があり、規定クラスがクラスではなく広域の変数定義のための領域になってしまう(広域変数).
    - 型フィールドによる問題を解決するのが`仮想関数（virtual function）`である
  - `オーバライド制限`:
    - `virtual`: 派生クラス先でオーバライド可能である
    - `=0`: 関数は virtual であって、派生クラス先で必ずオーバライドしなければならない
      - `純粋仮想関数(pure virtual function)` と呼ぶ. `=0` をつけることを`純粋化する`という
      - `純粋仮想関数` を一つでも保有するクラスを`抽象クラス`という
        - `抽象クラス`はオブジェクト化することができない
        - `抽象クラス`を用いた設計スタイルを`インターフェース継承(interface inheritance)`と呼ぶ(601)
    - `override`: 派生クラス先で基底クラスの仮想関数をオーバライド 
      - override はキーワードではなく、`文脈依存キーワード（contextual keyword）`と呼ばれるもので、クラス外で利用することはできない
        - override が文脈依存キーワードな理由は、override を普通の識別子として利用するコードが大量に作られてきたためである → 識別子と使用することを許可している.（例えば、override, final を変数名として使用することがきる.）
        - 他の文脈依存キーワードは final . final も同様にクラスの外で使用することができない
    - `final`: 派生クラス先でオーバライドすることができない
    - 上記の制限を全く用いなければ、基底クラスの virtual 関数をオーバライドする非 static メンバ関数は仮想関数になる(592)
  - ベストプラクティス: 仮想関数を追加するときには、virtual を利用して、オーバライドしようとする側では override を利用する
  - 言語のセマンティクスが変更されてしまっては困るクラス、一旦設計を閉じなければならない場合は仮想関数とすべきではない. (593)
  - クラス名の後ろに final をつけるとクラスの仮想関数は全て final となる. `class For_statement final: public Node{ ... }`. さらに、final されたクラスから派生することはできない.
  - `using 宣言`を使うと基底メンバを派生先の名前空間に持ち込むことができる. 関数多重定義解決では、基底メンバ一致度が最も高い場合それが選択されることになる.
  - `using 指令`で基底クラスの全メンバを持ち込むことはできない.
  - `仮想コンストラクタ(virtual constructor)`: virtual であって、しかも（間接的に）オブジェクトを構築する関数(599)
    - 適切なオブジェクトを作成するには、その正確な型をコンストラクタが知っておかなければならない. そのため、virtual にはなれない. さらに、コンストラクタを指すポインタを取り出すことはできないし、そのポインタをオブジェクト作成関数に渡すこともできない. そのため、オブジェクトの作成には仮想コンストラクタを使用する.
  - `protected`: 基底クラスに限定公開データを集約してしまうことに繋がったり、それがどのように変更されるのかについて全ての利用箇所を探し出すのが困難になることがあるため保守上の問題に繋がりやすい. 幸いなことに、限定公開データを利用する必要はない. 
    - `限定公開関数`は上記の問題には当てはまらない. (606)
  - `仮想デストラクタ(virtual destructor)`: 基底クラスが派生クラスへのポインタを指すときに、基底クラスを削除 (delete)すると、規定クラスのデストラクタは呼ばれるが、派生クラスのデストラクタは呼ばれないためリークする. 派生クラスのデストラクタを呼びたい時には、仮想デストラクタにして、派生先でオーバライドする.
    - If you want to prevent the deletion of an instance through a base class pointer, you can make the base class destructor `protected` and `nonvirtual`; by doing so, the compiler won't let you call `delete` on a base class pointer.
    - [Ref](https://stackoverflow.com/questions/461203/when-to-use-virtual-destructors)
  - `メンバへのポインタ`: `->*`や `.*`を使って、メンバ関数をポインタ経由で呼び出す手法:
    - `p->*m`: ポインタ p が指すオブジェクトにメンバ m を結びつける
    - `obj.*m`: オブジェクト obj にメンバ m を結びつける
    - 通常のポインタとは違う.
      - static なメンバはメンバへのポインタになりえない.
    - メンバ関数へのポインタは、関数名が不明な場合に利用される
    - `通常のポインタとメンバへのポインタのセマンティクスの違い`:
      - `通常のポインタ`: `void(*p)() = &Task::schedule;` 関数 schedule へのポインタを p へ代入
      - `メンバへのポインタ`: `void (Task::* pm)() = &Task::schedule;`
  - `反変性(contravriance)`: 規定クラスのメンバを派生クラスのメンバへのポインタ経由で変更することは安全であるが、その反対は安全でない. この性質を`反変性`という.
    - 「ポインタは、そのポインタをさすために必要な最小限の性質を持っていないオブジェクトは指さない」という基本的な原則に従うと、規定クラスのメンバへのポインタへ、派生クラスの関数へのポインタを代入するということは実行時エラーにつながる.(612)
    - `void (Base::* pmb)() = &Derived::print; // error`: Base は print を持たない
    - `void (Derived::* pmd)() = &Base::start; // ok`: Defived は間違いなく start を持つ
- `クラス階層`:
  - `実装継承`:
    - 基底クラスに固有のドメイン名を使用しないこと. 多くのバージョンを作成したいなら名前空間に宣言したり、別のクラスとして置いておくなど規定クラスの上のクラスとして設計しないようにする(616)
    - 基底クラスに限定公開データを用いない(616) :
      - 無関係のデータを持たせてしまい混乱の原因になる
      - 基底クラスの変更があった場合、全ての派生クラスを再コンパイルしないといけない
      - クラス実装者に自由にアクセスさせたいなら、派生クラスで自由に宣言して利用させる
  - `インターフェース継承`:
    - `多重継承（multiple inheritance）`: あるクラスからは実装を継承して、別のクラス（抽象クラス）からはインタフェースを継承する、というのは継承や、コンパイル時インタフェースチェック機能がある全ての言語にとって一般的である(619)
    - 通常は、より限定的なクラスを実装階層内に導入すると実装が改善される(621)
      - これにより限定的なクラスをオリジナルの基底クラスを含めたクラス階層を汚さないで構築することができる
      - 多重継承した際の同名の関数を派生先で解決するには、override せずに同じ型を持つ同名を再定義する。そうすると基底クラスの全ての関数をオーバライドする.(628)
       - もしセマンティクスが全く異なる関数で（例えば、draw 関数で一つは画面に描画する関数、もう一方はカーボーイが拳銃ケースからガンを抜く関数）複数継承した場合は、スーパークラスと継承先クラスの間にインタフェースそうを追加することで解決する(629)
  - `基底クラスの反復`: 複数の基底クラスの仮想関数は、対応する基底クラスの関数を呼び出して、その後に派生クラス独自の処理を実行する `f(){ A::f(); B::f(); cout << "Derived::f()" << endl; }`. 別々の関数としてオーバライドしたい場合は、上記の方法でレイヤを挟むようにする. (632)
  - `仮想基底クラス`: 基底クラスが同じである場合、デフォルトだと同じ基底クラスは別々のオブジェクトとなる. 問題なのは、ストレージ管理するようなクラスで同じファイルパスを持っていている際に、別々なオブジェクトがそれぞれ同じ書き込みを実行してしまうようなことがある. これを解決するために `仮想基底クラス` を用いて、同じ基底クラスは同じ１つとして派生するようにする. こうすることで共有が必要なクラスを一つにすることができる.
    - `仮想基底クラス` のコンストラクタは１度だけしか実行されないことが保証される
    - `仮想基底クラス` のコンストラクタは`最派生クラス`で実装しなければならない. これは、どのスーパクラスがすでに実装済みであるかどうかにかかわらずで、それは最派生クラス以外どの実装を優先して実行すればよいか曖昧だからである.(635)
  - `仮想基底クラスメンバを１回だけ呼び出す`: 仮想規定をそれを呼び出す関数でラップし、派生先で直近のスーパクラス(`直接規定クラス`)のラップ関数を呼び出すようにする.(636)
    - 仮想基底クラスのコンストラクタと同様に、仮想基底クラスのメンバは１回だけしか呼び出されない.(635)
  - `仮想規定関数のオーバライド`: 派生クラスは、直接基底、間接基底の仮想関数をオーバライドできる. 
    - 異なる２つのクラスが、同じ仮想基底の別々の仮想関数をオーバライドするとそれらの派生クラスはその両方を継承しないと、クラス階層ないで同じ関数をオーバライドしようとした時にエラーとなる.(639)
      - 仮想基底クラスの、全部ではなくて、一部のみを提供するクラスは、`ミックスイン(mixin)`と呼ばれる.

  