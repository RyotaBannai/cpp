### General concepts

- `左辺値`（`lvalue`）：メモリ上の特定の場所に置かれ、他のオブジェクトが同じ内容を持っていてもアドレスによって識別することができるオブジェクト
- `右辺値`（`rvalue`）：右辺値とは違ってアイデンティティを持たない（＝いつでも安全に参照することができるアドレスを持たない）オブジェクト。=> 「低コストでムーブできる値である」と言われる（Rust はもとよりオブジェクトの代入は、所有権の移動によるムーブが発生する）(14)

- `実行時オーバーヘッド`を伴う実装は排除されている。例えば、全オブジェクト内に`管理機能（housekeeping information）`を埋め込んだ上での構築は排除されている。そのため、２個の 16 ビットフィールドを持つ構造をユーザが定義すると、１個の 32 ビットレジスタに収まる。`new`, `delete`, `typeid`, `dynamic_cast`, `throw 演算子`, `try ブロック`を除くと、C++の式と文に対して、実行時の支援が必要となることはない。(17)
- `波括弧 {} で変数を初期化`：暗黙裏の型変換を許容しない。C のような伝統的な`= 代入演算子`で値を C++ でそのまま代入すると、暗黙裏の型変換が行われる。そのため波括弧の使用が推奨される(49)
- `定数（const）`
  - `const` 修飾子をつける（関数の引数に渡した時に変更されないことを保証）
  - `constexpr` コンパイル時に評価されることを明示し（つまり関数の計算結果を変数に代入する際にその修飾子として使う）、読み取り専用のメモリ領域に配置することを許可するとともに変更不可にする（性能も向上）
    - `constexpr` で修飾された変数は`定数式`にする。そうでないとそれ自体が定数式にならない（例：`const double v = 2.1; constexpr double d = sum(v)`）(51)
- `組み込み型（built-in type）`: `基本型（bool, char など）`・`const 修飾子`・`宣言演算子（declarator operator）(&, *, [])`とで組み合わされる型
- `ユーザー定義型(user-defined type)`: C++ の抽象化機構（abstraction mechanism）(クラスや列挙型など)を使ってユーザーが定義できる型(55)
- `インターフェース`: Vector の`内部データ表現`である 2 つのメンバ `elem`, `sz` は `public メンバであるインターフェース`、すなわち `Vector()`, `operator[]()`, `size()` を介してのみアクセスできる(57)
  - C++ におけるインターフェースは Go や Rust などの impl するためのメソッドの型の集まり、とすることもできるし、
  - 内部データ表現を操作するためのメソッドの定義とすることもできる（Rust のコンテキストで言うとインターフェースに定義されている実際の具象 method）
- `クラスの普遍条件（class invariant）または単に 普遍条件（invariant）`: クラスを初期化するときに必要となる前提条件を表す文であり、これはコンストラクタが保証しなければならないが、その内容は実装者の責任である。例えば、適切に `std::length_error`, `std::bad_alloc` など検出したエラーを呼び出し側に通知する必要がある。呼び出し側はこれらを適切に補足する必要がある。(64)
- `静的アサーション`: エラーを型チェックなどと同様なコンパイルエラーとして検出するための機構である。例えば、`static_assert(4 <= sizeof(int), "integers are too small");`(65)
  - 静的アサーションは、ジェネリックプログラミングの引数型に対して使うことが効果的である
  - static_assert を使うときは、条件部分に使う変数は定数でないといけない
