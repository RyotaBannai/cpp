### General concepts

- `左辺値`（`lvalue`）：メモリ上の特定の場所に置かれ、他のオブジェクトが同じ内容を持っていてもアドレスによって識別することができるオブジェクト
- `右辺値`（`rvalue`）：右辺値とは違ってアイデンティティを持たない（＝いつでも安全に参照することができるアドレスを持たない）オブジェクト。=> 「低コストでムーブできる値である」と言われる（Rust はもとよりオブジェクトの代入は、所有権の移動によるムーブが発生する）(14)

- `実行時オーバーヘッド`を伴う実装は排除されている。例えば、全オブジェクト内に`管理機能（housekeeping information）`を埋め込んだ上での構築は排除されている。そのため、２個の 16 ビットフィールドを持つ構造をユーザが定義すると、１個の 32 ビットレジスタに収まる。`new`, `delete`, `typeid`, `dynamic_cast`, `throw 演算子`, `try ブロック`を除くと、C++の式と文に対して、実行時の支援が必要となることはない。(17)
- `波括弧 {} で変数を初期化`：暗黙裏の型変換を許容しない。C のような伝統的な`= 代入演算子`で値を C++ でそのまま代入すると、暗黙裏の型変換が行われる。そのため波括弧の使用が推奨される(49)
- `定数（const）`
  - `const` 修飾子をつける（関数の引数に渡した時に変更されないことを保証）
  - `constexpr` コンパイル時に評価されることを明示し（つまり関数の計算結果を変数に代入する際にその修飾子として使う）、読み取り専用のメモリ領域に配置することを許可するとともに変更不可にする（性能も向上）
    - `constexpr` で修飾された変数は`定数式`にする。そうでないとそれ自体が定数式にならない（例：`const double v = 2.1; constexpr double d = sum(v)`）(51)
- `組み込み型（built-in type）`: `基本型（bool, char など）`・`const 修飾子`・`宣言演算子（declarator operator）(&, *, [])`とで組み合わされる型
- `ユーザー定義型(user-defined type)`: C++ の抽象化機構（abstraction mechanism）(クラスや列挙型など)を使ってユーザーが定義できる型(55)
- `インターフェース`: Vector の`内部データ表現`である 2 つのメンバ `elem`, `sz` は `public メンバであるインターフェース`、すなわち `Vector()`, `operator[]()`, `size()` を介してのみアクセスできる(57)
  - C++ におけるインターフェースは Go や Rust などの impl するためのメソッドの型の集まり、とすることもできるし、
  - 内部データ表現を操作するためのメソッドの定義とすることもできる（Rust のコンテキストで言うとインターフェースに定義されている実際の具象 method）
- `クラスの普遍条件（class invariant）または単に 普遍条件（invariant）`: クラスを初期化するときに必要となる前提条件を表す文であり、これはコンストラクタが保証しなければならないが、その内容は実装者の責任である。例えば、適切に `std::length_error`, `std::bad_alloc` など検出したエラーを呼び出し側に通知する必要がある。呼び出し側はこれらを適切に補足する必要がある。(64)
- `静的アサーション`: エラーを型チェックなどと同様なコンパイルエラーとして検出するための機構である。例えば、`static_assert(4 <= sizeof(int), "integers are too small");`(65)
  - 静的アサーションは、ジェネリックプログラミングの引数型に対して使うことが効果的である
  - static_assert を使うときは、条件部分に使う変数は定数でないといけない
- `インライン化`: 効率を重視すると、単純な演算はインライン化することになる。すなわち`コンストラクタ`、`+=`、`imag()` などの`単純な演算`は、関数呼び出しの機械語が生成されないように実装しなければならない(69)
  　 - クラス内で定義する関数は、デフォルトでインライン化される。
- `資源獲得時初期化(RALL = Resource Acquisition Is Initialization)`: コンストラクタで資源（メモリ）の獲得を行い、デストラクタで必ず資源の解放をする技法（または、`データハンドルモデル（handle-to-data model）`の一つである）
  　- `裸の new 演算`や `裸の delete 演算`を内部に隠蔽する、かつスコープなどから抜けると必ず呼び出されるので資源（メモリ）リークやエラーを防ぎやすくなる(72)
- `コンテナ（Vector など）の初期化`: `std::initializer_list<T>` を使う(73)
- `抽象型(abstract type)`: データの定義ではなく、型を定義したクラス（インターフェースを分割したものとは別）
  - 具象クラス（concrete class）で実装を行うことを想定した関数定義を `仮想関数（virtual function）` と言い、`virtual 修飾子`をつける
  - 仮想関数には `=0` という記法をつけた`純粋仮想(pure virtual)関数`と言う種類の仮想関数があり、その関数は具象クラスで`必ず`実装しなければいけない
  - `具象型`は一般的に`多相型（polymorphic type）`として使われる
- メンバのデストラクタ（クラスのメンバとして持つオブジェクト自身のデストラクタ）は、クラスのデストラクタから暗黙裏に呼ばれる. また、具象型のデストラクタは抽象型のデストラクタを自分のクラス名でオーバーライドできる。
  - クラス階層（class hierarchy）の場合仮想関数の呼び出しの仕組みによって適切なデストラクタが呼ばれる。派生クラスのデストラクタは暗黙裏に基底クラスのデストラクタも呼び出す(78)
- `仮想関数テーブル（vtbl）`: 抽象クラスが実際の具象クラスの実装された関数を呼び出す仕組み（各具象クラスごとに作成して、関数の位置をインデックスを振ってマッピングしたテーブル）(76)
  - メモリのオーバーヘッドは、抽象クラスが保持する`具象クラスへのポインタ`と、`具象クラスの vtbl へのポインタ`
- `unique_ptr`: ユーザーが不要なポインタを delete しない可能性、または失敗する可能性がある。そのため、スコープから抜けるときに不要になったポインタを自動で削除するための機構が`unique_ptr`である
