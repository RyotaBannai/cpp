### General concepts

- `左辺値`（`lvalue`）：メモリ上の特定の場所に置かれ、他のオブジェクトが同じ内容を持っていてもアドレスによって識別することができるオブジェクト
  - `左辺値`じゃない式(267):
    - `int *q = &(x++);` ただし、`int *q = &++x;` は `p` は `x` を指すので左辺値
    - `int &r = (x < y) ? x : 1` → `1` は左辺値じゃない
- `右辺値`（`rvalue`）：右辺値とは違ってアイデンティティを持たない（＝いつでも安全に参照することができるアドレスを持たない）オブジェクト。=> 「低コストでムーブできる値である」と言われる（Rust はもとよりオブジェクトの代入は、所有権の移動によるムーブが発生する）(14)

- `実行時オーバーヘッド`を伴う実装は排除されている。例えば、全オブジェクト内に`管理機能（housekeeping information）`を埋め込んだ上での構築は排除されている。そのため、２個の 16 ビットフィールドを持つ構造をユーザが定義すると、１個の 32 ビットレジスタに収まる。`new`, `delete`, `typeid`, `dynamic_cast`, `throw 演算子`, `try ブロック`を除くと、C++の式と文に対して、実行時の支援が必要となることはない。(17)
- `波括弧 {} で変数を初期化`：暗黙裏の型変換を許容しない。C のような伝統的な`= 代入演算子`で値を C++ でそのまま代入すると、暗黙裏の型変換が行われる。そのため波括弧の使用が推奨される(49)
  - この手法は、`並びによる初期化(list initialization)と呼ばれる`. この初期化では、`縮小変換`を許さない例えば：(169)
    - 整数値は、その値を保持できない他の整数型へ変換されない。例えば、`char から int`
    - 浮動小数点数値はその値を保持できない他の浮動小数点型へ変換されない。例えば、`double から float`
    - `浮動小数点数値`は`整数型`へ変換されない/ `整数値`は`浮動小数点数値`へ変換されない
  - `auto` を使うときは = を使う方が良い。なぜなら例えば`auto z {99};` の型は `initializer_list<int>` になってしまう
    - そのため、`並びではないオブジェクト(container のようなオブジェクト)`の初期化は `=` を利用するのが良い(または併用 `={}`)
- `定数（const）`
  - `const` 修飾子をつける（関数の引数に渡した時に変更されないことを保証）
  - `constexpr` コンパイル時に評価されることを明示し（つまり関数の計算結果を変数に代入する際にその修飾子として使う）、読み取り専用のメモリ領域に配置することを許可するとともに変更不可にする（性能も向上）
    - `constexpr` で修飾された変数は`定数式`にする。そうでないとそれ自体が定数式にならない（例：`const double v = 2.1; constexpr double d = sum(v)`）(51)
- `組み込み型（built-in type）`: `基本型（bool, char など）`・`const 修飾子`・`宣言演算子（declarator operator）(&, *, [])`とで組み合わされる型
- `ユーザー定義型(user-defined type)`: C++ の抽象化機構（abstraction mechanism）(クラスや列挙型など)を使ってユーザーが定義できる型(55)
- `インターフェース`: Vector の`内部データ表現`である 2 つのメンバ `elem`, `sz` は `public メンバであるインターフェース`、すなわち `Vector()`, `operator[]()`, `size()` を介してのみアクセスできる(57)
  - C++ におけるインターフェースは Go や Rust などの impl するためのメソッドの型の集まり、とすることもできるし、
  - 内部データ表現を操作するためのメソッドの定義とすることもできる（Rust のコンテキストで言うとインターフェースに定義されている実際の具象 method）
- `クラスの普遍条件（class invariant）または単に 普遍条件（invariant）`: クラスを初期化するときに必要となる前提条件を表す文であり、これはコンストラクタが保証しなければならないが、その内容は実装者の責任である。例えば、適切に `std::length_error`, `std::bad_alloc` など検出したエラーを呼び出し側に通知する必要がある。呼び出し側はこれらを適切に補足する必要がある。(64)
- `静的アサーション`: エラーを型チェックなどと同様なコンパイルエラーとして検出するための機構である。例えば、`static_assert(4 <= sizeof(int), "integers are too small");`(65)
  - 静的アサーションは、ジェネリックプログラミングの引数型に対して使うことが効果的である
  - static_assert を使うときは、条件部分に使う変数は定数でないといけない
- `インライン化`: 効率を重視すると、単純な演算はインライン化することになる。すなわち`コンストラクタ`、`+=`、`imag()` などの`単純な演算`は、関数呼び出しの機械語が生成されないように実装しなければならない(69)
  - クラス内で定義する関数は、デフォルトでインライン化される。
- `資源獲得時初期化(RALL = Resource Acquisition Is Initialization)`: コンストラクタで資源（メモリ）の獲得を行い、デストラクタで必ず資源の解放をする技法（または、`データハンドルモデル（handle-to-data model）`の一つである）
  - `裸の new 演算`や `裸の delete 演算`を内部に隠蔽する、かつスコープなどから抜けると必ず呼び出されるので資源（メモリ）リークやエラーを防ぎやすくなる(72)
- `コンテナ（Vector など）の初期化`: `std::initializer_list<T>` を使う(73)
- `抽象型(abstract type)`: データの定義ではなく、型を定義したクラス（インターフェースを分割したものとは別）
  - 具象クラス（concrete class）で実装を行うことを想定した関数定義を `仮想関数（virtual function）` と言い、`virtual 修飾子`をつける
  - 仮想関数には `=0` という記法をつけた`純粋仮想(pure virtual)関数`と言う種類の仮想関数があり、その関数は具象クラスで`必ず`実装しなければいけない
  - `具象型`は一般的に`多相型（polymorphic type）`として使われる
- メンバのデストラクタ（クラスのメンバとして持つオブジェクト自身のデストラクタ）は、クラスのデストラクタから暗黙裏に呼ばれる. また、具象型のデストラクタは抽象型のデストラクタを自分のクラス名でオーバライドできる。
  - クラス階層（class hierarchy）の場合仮想関数の呼び出しの仕組みによって適切なデストラクタが呼ばれる。派生クラスのデストラクタは暗黙裏に基底クラスのデストラクタも呼び出す(78)
- `仮想関数テーブル（vtbl）`: 抽象クラスが実際の具象クラスの実装された関数を呼び出す仕組み（各具象クラスごとに作成して、関数の位置をインデックスを振ってマッピングしたテーブル）(76)
  - メモリのオーバーヘッドは、抽象クラスが保持する`具象クラスへのポインタ`と、`具象クラスの vtbl へのポインタ`
- `unique_ptr`: ユーザーが不要なポインタを delete しない可能性、または失敗する可能性がある。そのため、スコープから抜けるときに不要になったポインタを自動で削除するための機構が`unique_ptr`である(80)
- `資源ハンドル(resource handle)`: ポインタ経由でオブジェクトにアクセスしなければならないこと
  - 配列を使うとリークを起こしていないか木を配る必要があるので、基本的には内部に資源ハンドルを持つ（所有権を表すポインタ） `vector`, `string`, `unique_ptr`を使うこと(195)
  - 反対に資源ハンドルの外部に存在するポインタ（new を使って空き領域にメモリを確保して割り当てた配列など）は自分で `delete` する必要がある、とすると資源管理を単純化することができる(196)
- `クラスオブジェクトのコピー動作`: 以下の２つを検討すると良い.(通常のコピーでは、同じアドレスを参照していまい mutable なオブジェクトになってしまうため)(82)
  - `コピーコンストラクタ（copy constructor）`: `Vector(const Vector& a);`: 必要なメモリを確保し、与えられたオブジェクトと同じ内容をコピーする。そうすると元のオブジェクトとは別のメモリ常に新しいオブジェクトを作成することができる
  - `コピー代入（copy assignment）`: `Vector& operator=(const Vector& a);`: 同様に必要なメモリを確保し、内容をコピーする。その後に元のオブジェクトを削除する. コピーコンストラクタと違うのは、代入操作なので新しいオブジェクトを返却しないといけない点であり、これには　`*this` を使う.
- 階層内のクラスに対して、デフォルトのコピーやムーブを利用すると、ほとんどの場合は惨事につながる。と言うもの、基底を指すポインタだけ与えられても、派生クラスのメンバについては何もわからないからでさる。こう言う場合には、デフォルトのコピー演算、ムーブ演算を削除(delete)するのが良い。(`Shape& operator=(Shape&&) =delete`)
  - また、デストラクタを宣言しておけば、これらの delete を忘れても実害がない。と言うのも、ユーザーが明示的にデストラクタを宣言したクラスに対しては、デフォルトの`ムーブ演算`が暗黙裏には生成されないからである。さらに、この場合の`コピー演算`は非推奨になっている。このため、コンパイラが暗黙裏にデストラクタを作成するとはいえ、ユーザーが明示的にデストラクタを定義する理由の一つである。(85)
- テンプレートの活用で有益なのが`関数オブジェクト（function object）`/` ファンクター（functor）`である：あたかも関数のようにオブジェクトを呼び出すことができる
  - 汎用アルゴリズムの中核となる演算を指定するための、関数オブジェクトを`ポリシーオブジェクト(policy object)` という。
  - 関数オブジェクトを簡潔な内容であれば、ラムダ式（lambda function）を使って全く同じオブジェクトを生成することができる.(`[&](int a) { return a < x; }`)
    - `[&], キャプチャ並び(capture list)`：使っている`局所名（local name: x など、関数で宣言される変数名）`を参照を介してアクセスすることを表す
    - x だけキャプチャしたい場合 `[&x]`, x のコピーとしてオブジェクとを生成した場合は`[=x]`と記述
- `conditional_variable`: lock とイベント待ち: 他のスレッドの結果によってなんならかの条件が成立するまで、別のスレッドを待機させる、と言ったことが可能.(127)
  - 関数の中では、初めに `mutex` を取得し、`conditional_variable.wait(unique_lock<mutex>)` で、`mutex` を解放し wait する。condition が成立したら（待機が終わったら）、再度 `unique_lock<mutex>` を取得し、ロックをかける。
  - condition が成立したことを通知するには、`conditional_variable.notify_one()` で行う
- `tag dispatch（タグ指名）`: overload, single/multi dispatch を前提とした機能で、iterator pattern をアルゴリズムに適用したもの.
  - タグと呼ばれる、組み込みの機能（例えば、`std::random_access_iterator_tag（for vector）`, `std::forward_iterator_tag（for forward_list）`）を関数の引数として使い、コンパイル時に複数のアルゴリズムのうちから１つ選択することができる機能
  - このタグを取得するために、`iterator_traits` (この場合は container )などから tag を取得することができる
  - また、こういった関数（/アルゴリズム: 引数あるいは返却値として、ある型が与えられて、コンパイル時に評価される関数）を`型関数(type function)`と言う(132)
- `型述語`：型に関する基本的な情報を返却するための単純な`型関数`である。このような述語（predicate）は、`<type_traits>`で提供される
- `make_pair()` を使うと、明示的な型の記述が不要になるため pair の作成が容易になる(135)
- その機能に、理屈通りで容易に実装できる別の方法が複数あれば、その機能は、`定義されない（undefined）`ではなく、`指定されない（unspecified）`あるいは、`処理系定義（implementation defined）`である(144)
- 標準が指定しない、あるいは、定義しない、とするものを使わないように努力することは、そのための時間と労力に見合うはずである(145)
- `void`: `返却値を返さない関数の型`、または`型がわからないオブジェクトを指すポインタの型`として利用(157)
- `size_t`: 処理系定義の符号無し整数型、`ptrdiff_t`: 要素数を求めるための、ポインタどうしの差の演算結果を保持できる. このように標準ヘッダは処理系に依存しない型の大きさを定義した`型別名`を提供する（`<cstdint>`, `<stddef>`など）
- `値を指定する宣言`は、全て`定義`である(162)
- `関数定義`と`名前空間定義`を除くと、`全ての宣言`はセミコロンで終了する(162)
- `予約済みの名前`：`下線で始まる非局所変数`, `２個の下線を含む名前`、`下線で始まって直後に大文字が続く名前`など（`_class`, `trouble__ahead`, `_Foo` など）
- `参照はずし`: C++ では参照は、式の中で暗黙裏に反証外しを行われている(Go と同じ) `void g(int& v) { auto x = v;}` この場合、`&v` は暗黙裏に参照外しされ、`v` となる。もし参照としてオブジェクトを保持したいなら、`auto &x = v;` とすれば良い.
- `配列`を`空き領域`に割り当てた場合（`new int[40]`をした場合。）は、必ず使用後に１度削除しなければならない（`delete[]`）。`スタック領域`（`int a[20]`）や、静的に割り当てた場合（`静的記憶域`に格納した場合、global, 関数・クラス内の static をつけて宣言した変数など）は`delete[]`してはいけない。
- C と同様に初期化された配列に再代入することはできない。そのためオブジェクトの集合を代入したいときは、vector, array, valarray を使う(184)
- `文字列リテラル`: C++ では const ととして定義する。もし、非 const にしたいなら配列で宣言すること(185):
  - const: `const char* p = "Plate"` (const は静的に割り当てられるため、関数の返却値としても安全に利用できる（関数終了後も存在し続ける・アドレスが変わらない・move しない・）)
  - 非 const: `char p[] = "Plate"`
  - さらに文字列リテラルは最適化のため全く同じ内容の文字列を同じアドレスとして保持する場合がある。その際に別々の変数を比較して同じアドレスを指しているかどうか（同じ文字列かどうではなく）で確認することができる
- `ポインタ`の扱いは大変（メンバへのアクセス方法などの違い）なので、`参照`を利用する
  - `参照`の主な用途は、`関数`あるいは`多重定義された演算子`の`引数`と`返却値`
  - 参照の種類:
    - `左辺値参照`(`lvalue reference`): その値を変更したいオブジェクトへの参照(`v[2] = 7;`)
    - `const 参照`(`const reference`): その値を変更したくないオブジェクトへの参照（定数など）(`f(const &v){...}`)
    - `右辺値参照`(`rvalue reference`): 利用した後で、その値を保持する必要がないオブジェクト（例えば、一時オブジェクト）への参照(`v.push_back(v[2]);`)
      - 高コストなコピー演算を、低コストなムーブ動作に置換できるかどうかを決定するのは、参照が一時オブジェクトを参照しているかどうかに依存する
      - その値を保持する必要がない時とは例えば`局所変数`のを返す関数の返却値があげられる
  - 参照はオブジェクトを指す. 参照から参照先のオブジェクトへのポインタを取得する場合は、`int var = 0; int &rr {val}; int *p = &rr;` のように`&rr`する
  - `単なる参照`と`const の参照`では初期化時の挙動が異なる
    - `単なる参照`: 異なる型で初期化することはできない
    - `const の参照`: 異なる型で初期化することはできる. 異なる場合、const への参照型へキャストされる. 例えば、`const double &cdr {1}` は double 型になる(199)
      - このキャストが行われる際には、temp の変数が作成されこれは参照のスコープかを抜け出すまで存在し続ける(199)
    - `Map` 型の場合は線形探索などの函数の返却値に参照が使用される。と言うのも、返却値の value をよく更新されるのに使用されることが多いからである。
- `参照への参照`: 左辺値参照が常に勝つ. (`参照崩壊`（`reference collapse`）と呼ばれる)(204)
  - 例) `int && && -> int&&`, `int && & -> int&`, `int & && -> int&`, `int & & -> int &` となる.
- ポインタなどの組み込み型どうしの演算（例えば、`&a + &b` のように参照演算子がついた型どうしの演算）を行う演算子は（再）定義できない
  - `a + b` のように非組み込み型であれば問題なく、この場合参照を引数として `+` `-` などの演算子定義することができる
- `sturct`: struct は通常アライメントされるので、メモリを大きく占めるメンバを先に宣言するとことで穴を埋めることができる（可読性が失われる可能性があるが）
  - `アクセス指定子`(`public`, `private`, `protected`): を複数利用すると、レイアウトが変わってしまう(212)
  - `struct` は型の宣言さえすれば、実装前に使用することができる(213)
  - また `非 struct` と同一名の変数や関数などを宣言することできる（これは同名で多重定義しても `struct キーワード`の前置きが必要で区別できるため. ただ曖昧さを排除するために推奨はされない）
  - `struct` はたとえメンバの構成が同一でも、個々の struct はそれぞれが別々の型となるので、比較演算子での比較は常に `false` になる
- `POD`(`Plain Old Data`): `C 互換データ`: 複雑なクラスレイアウトや、構築、コピー、ムーブなどのユーザ定義の瀬マンティクスを配慮することなく、`単なるデータ`として利用できるオブジェクトである. `POD`であるための条件として主に以下の 3 つを満たす必要がある(218):
  - `標準レイアウト型`(`standard layout type`)
  - `トリビアルにコピー可能な型`（`trivially copyable type`）
    - `トリビアル型`（`trivial type`）:
      - トリビアルなデフォルトコンストラクタ
      - トリビアルなコピー動作及びムーブ動作
  - `トリビアルなデフォルトコンストラクタを持つ型`:　`struct{ int a; S(int a): a(aa){} }; // POD ではない（デフォルトコンストラクタがない）`(デフォルトの詳細は`17.6`)
  - 標準ライブラリ `<type_traits>` の `is_pod<T>` で `T` が `POD` かどうかチェックできる(219)
- `共用体(Union)`: `タグ付き共用体(tagged union)` あるいは、`判別共用体(discriminated union)` を使って Union の誤用を防ぐための実装を施すことができる(224)
  - この場合クラスのフィールドとして Union を持つことになるが、`無名共用体(anonymous union)（無名共用体は型はなくオブジェクトである）`を宣言してその各メンバには直接アクセスすることでアクセスする
  - string などの変種を使う場合は、デストラクタや setter など所々で`'明示的に'`解体(`s.~string();`)するようにすることで可読性や誤用を防ぐことができる
- `選択文`:
  - `if 文`:
    - 整数定数を渡した時は暗黙裏に bool に変換され、`x != 0` の判定が行われる
    - pointer を渡した時は暗黙裏に nullptr かどうか `p != nullptr` の判定が行われる
    - enum は暗黙裏に bool に変換され、整数定数と同様に判定される
    - enum class は暗黙裏に変換`されない`
    - `条件内の宣言`を積極的に活用する. スコープを局所化でき、ソースコードがコンパクトになる(240)
      - 条件での宣言は、`単一の変数`、あるいは`const の宣言と初期化`に限られる
  - `switch 文`:
    - case ラベルに用いられる式は、`汎整数型`か`列挙体型の定数式`でなければならない
    - `汎整数型`でなければならないため、string は使用できないが、ハッシュ値を用いることで実現できる [ref](https://stackoverflow.com/questions/650162/why-the-switch-statement-cannot-be-applied-on-strings)
    - switch 分内で変数が必要であれば、その宣言をスコープ内に入れ、その利用もブロック内に制限すれば良い。その具体例はとして `prim()` の利用である(240)
- `通常の算術変換(the usual arithmetic conversion)`: 算術演算に置いてメモリの占有領域が大きい型に自動的に格上げする手法で、C++ でもそれを採用(267)(279)
- `評価順序`:
  - 式の評価順序に決まりはないので、`x = f() + g()` のような場合、`f()`, `g()` のどちらが先に評価されるかどうかはわからない
  - `x[i] = ++i;` のような式では、`x[1]`または `x[2]`になりえるので、読み込みと書き込みを同じ式に書くのは避ける
  - 評価順序が明確にするための演算子を活用する:
    - `順次演算子`では左から先に評価される: `f( (v[i], ++i) )` (`f(v[i], ++i)`とした場合の動作は定義されない)
- `一時オブジェクト（temporary）`: コンパイラが中間結果を保持するために導入するオブジェクト. `v = x+y*z` のうち `y*z`の計算結果を一時オブジェクトに置いておき、後から x との演算に利用
  - 一時オブジェクトは`完全式(full expression)` が評価された後に完全に解体（解放）される. そのため思わぬ挙動を生む可能性がある. 一時オブジェクトへの参照を取得しようとする実装をしないようにする. 例えば、`const char* cs = (string1 + string2).c_str();` は動作しない
  - 一時オブジェクトは `const の参照`や`名前付きオブジェクトの初期菓子`として利用できる。この場合一時オブジェクトはそのオブジェクトがスコープから抜けて解体される時に一緒に解体される
  - `局所変数への参照を返すのは誤りである`ことと`一時オブジェクトは 非 const 左辺値参照にバインドできない`ことを覚えておく(271)
  - `式の中で明示的にコンストラクタを呼ぶと一時オブジェクトが生成される`(`s.move(string(n, ch))` → string コンストラクタを呼び出して直接 move に渡す → 一時オブジェクトが作成される)
- `縮小変換(narrowing conversion)` せざるをえない場合は、`narrow_cast<>()` の利用を検討
- `特殊化(specialization)`: テンプレートはデフォルトでたった一つの定義でユーザーがから考えられるあらゆるテンプレート引数（あるいはその組み合わせ）で利用できるようになる. しかし、このことは、テンプレート開発者にとって必ずしも理にかなっていることではない. "テンプレート引数がポインタだったら、こちらの実装を利用して、ポインタでなければあちらの実装を利用する"など、設計上の問題の多くは、テンプレートの大体実装をあらかじめ定義しておき、実際の利用時に与えられたテンプレート引数に基づいて、コンパイラに選択させることで解決できる。`テンプレートのこのような大体実装は`、`ユーザ定義特殊化(user-defined specialization)` または単に`ユーザ特殊化(user specialization)`と呼ばれる.(730)
- 名前付きオブジェクトの生存期間はスコープが決定するが、スコープに依存せずに生存可能なオブジェクトを作成すると役立つことも多い。例えば、関数の返却値として名前付きオブジェクトの参照を返す時などである（この際は返却先で delete で解体する）。ただ返却値として利用するために new を使うのではなく、move を使って所有権を移動させることで所有者がスコープを抜けた時に自動で解体されるようにする方が object leak を防ぐには better(288)

  - そのための機構 `new`（によってメモリを割り当てる）であり、それを解体するのが `delete` である. (`空き容量 (free store) 上にある`、`ヒープ(heap) 上にある`、 `動的メモリ(dynamic memory) の中にある`、ともいう.)
  - `局所変数(local variable)`（関数内で宣言する変数）で`裸の new 演算子`は避ける（unique_pointer などでラップする）
    - `delete[]` で解体できるのは、`new で確保した配列をさすポインタ`か、あるいは、`空ポインタ`であり、空ポインタの場合は何もしない.

- `配置構文(placement syntax)`: new では空領域にメモリを確保するが、特定のアドレスに割り当てることもできる. この場合、new にそのアドレスを void* 型にキャストして渡す(`reinterpret_cast<void*>(0xF00F)`) この時確保されるオブジェクトの大きさは暗黙裏に決定される
- `nothrow new`: `new(nothrow) int[n]` のように `nothrow` を引数に渡すと、`bac_alloc 例外`が送出されずに `nullptr` が返却されるようになる
- `並び`: `{} 構文` 型修飾される場合その型で初期化を行う. 型修飾されていない場合は利用されている文脈に応じて型決定を行う.
  - `修飾並び`: S{..} のように型修飾されている並び(`S v{7,8}; // 変数の直接初期化 v = S{8,9}; // 修飾並びによる代入`)
  - `非修飾並び`: {} のように型修飾されてない並び(`int v{1} // 変数の直接初期化 v = {2}; // 非修飾並びによる代入`)
- `ラムダ`: 関数オブジェクトを定義する簡略法
  - `ラムダ`を用いる時は呼び出す川の生存期間よりも長くなる可能性がある場合は、参照としてキャプチャするかどうか慎重に判断する
  - `ラムダ`内でも名前空間内の名前を利用できるので、わざわざキャプチャする必要があるかどうか確認すること
- `関数`:
  - `引数の受け渡し`:
    - 関数名の後ろに置く`()`は`呼び出し演算子（call operator）`または、`アプリケーション演算子(application operator)` と呼ばれる
    - 関数を呼び出すと、関数の`仮引数（formal argument、またはパラメータ（parameter））`のためのメモリ領域が割り当てられ、個々の`仮引数`が対応する`実引数`によって初期化される
    - 引数に pointer を渡しても元のオブジェクトは変化しない（変更できるのは参照で渡されたオブジェクトのみ）. もし pointer の指すオブジェクトを変更したい場合は、参照で渡す(`void foo(type *&in) {...}`)
  - 関数に渡す引数は明示的に型変換される(`double sqrt(double); sqrt(2);` とすると暗黙裏に `sqrt(double{2})` なり型変換される)(313)
  - 行列などでは入れ子のループには内積を用いると良い
  - 関数にバグが忍び込むのは、アルゴリズムの一部しか確認できないような時であるので、約 40 行を関数の上限とするようにする（ビャーネストラウストラップは 7 行を理想としている）
  - 関数の呼び出しがコストになることはあまりない。もし問題となる場合は、`インライン化`すればコストを削減できる
  - 関数宣言の構成要素(315):
    - `inline`: 関数呼び出し箇所に、関数本体を埋め込んで欲しいということを表す
      - `相互再帰`や`再起呼出し`を行うかどうかが、与えられた値に依存する関数などがインライン関数となることもあるため、インラインに必ず展開されるという保証はない(319)
    - `constexpr`: `関数の引数が定数式である場合`に、関数評価がコンパイル時に可能であることを表す
    - `noexcept`: `関数が例外を送出しないことを表す`
    - `[[noreturn]]`: 通常の呼び出し・リターンの機構下でも、`関数がリターンしないことを表す`
    - `結合指定`: 例えば `static` など
  - 引数:
    - `関数宣言`の引数は省略可能で、その引数名と`関数定義（関数本体を伴う関数宣言）`の引数名は違っていても良い
  - 関数定義の引数に名前を与えなくても良いが、その場合その引数を使用しないことを表す（コードの単純化や将来の拡張のために使う）
  - 後置形式の返却型を使う重要な用途が、引数に依存する返却型を持つ関数テンプレート宣言におけるものである. (`auto product(const vector<T>& x, const vector<U>& y) -> decltype(x*y)`)
  - main 関数を除いて、void 以外は必ず値を返さないといけない
  - 関数が値を返却するセマンティクス（`return`）は、引数受け渡しの背マンティクスと同様にコピー初期化と同じ。そのため、返却型の変数を初期化し、暗黙裏に型の変換が行われる (`double f() {return 1;} // 1 は double{1}`)(317)
  - コマンドライン引数を処理する場合は、伝統的な C スタイルの手法ではなく、コンテナを使った手法を取り入れる.
  - デフォルト引数を積極的に取り入れることでメンバ関数の記述量を圧倒的に軽減・保守性を高めることができる
- `One Definition Rule`: objects and non-inline functions cannot have more than one definition in the entire program and template and types cannot have more than one definition by translation unit.[Ref](https://en.wikipedia.org/wiki/One_Definition_Rule)
- `多重定義(overloading)`:
  - 同じ関数名で異なる別々の引数型に対して別々の処理を実装する（コンパイラが仮引数と実引数の型を比較して関数を`自動解決`する、また`返却型`は考慮されない）:
    - 関数の宣言順序は無関係
    - コンパイラは引数の一致度が一番高い関数を選択する（次のような場合は、優先度が同一の関数が複数あるためエラーとなる: `f(double, double); f(int, int); void main(){ f(2.0, 2); }`）
    - `Multi dispatch（複数の引数の自動解決）` をサポートする
    - 一致する関数がなければコンパイルエラーとなる
    - 詳細な自動解決の詳細は(334)を参照
  - テンプレートは多重定義された関数を一括りにする体型的方法を提供する:
    - `関数テンプレート`は、`引数一式に対する特殊化の結果に対して多重定義解決規則を適用することによって処理される`(335)
    - `{} 並びを使った場合の多重定義(初期化子並びが優先される)`と、`テンプレートの右辺値参照引数`には、別の規則が適用される(335)
  - 継承による同名関数の定義は多重定義にはならない.
    - `クラススコープや名前空間をまたがる多重定義`が必要であれば、`using 宣言`や `sing 指令`を用いる.
    - `実引数依存探索`を用いると名前空間をまたがる多重定義が可能
  - `多重定義`のメリット:
    - 関数の呼び出しの際に行われる引数の型変換のうちエラーに繋がりやすい`縮小変換`が起きるのを防ぐ（多重定義による変換では、`標準変換`が行われるのぜより安全な変換になる(334)）
  - 手動による解決:
    - `static_cast<int *>(0)` のように明示的型変換を用いる方法もあるが、このような一時凌ぎでは呼び出す箇所全て同じようにしないといけなくなってしまう
  - `事前条件`と`事後条件`(338):
    - 関数を呼び出した時に、引数の型はコンパイラやリンカが保証するが、実際に入ってくる値が不正な値に対処するのはプログラマの責任である.
    - `事前条件(precondition)`: 関数が呼び出された時点で保証されるべき論理的な規則
    - `事後条件(postcondition)`: 関数がリターンした時点で保証されるべき論理的な規則
    - 関数が非局所オブジェクトを利用・変更する場合は、その影響を考慮してドキュメント化しなければならない
  - `関数へのポインタ`:
    - `多重定義`された関数へのポインタを取り出す際には、関数の型(引数型と返却型)が使われる
    - `noexcept` 関数を指すポインタは、`noexcept` と宣言しても良い
    - `関数の結合`を反映したものでないといけない(343). `型別名(using)`の宣言では、`結合指定`と `noexcept 指定`は行えない(343).
    - `関数を指すポインタ`よりも、`関数オブジェクト（ラムダを含む）`や`仮想関数`を優先する
- `マクロ`:
  - マクロの利用で有用なのは`条件コンパイル`である.
  - いくつか定義済みマクロで有用なものがある. `__func__`, `__TIME__`, `__FILE__`, `__LINE__` あたりは便利.
- `エラー処理`:
  - `terminate()`: うまく機能するフォールトトレラントシステムは、数段階のレベルを持つ. 各レベルでは、ねじれを発生させすぎない範囲でできるだけ多くのエラーを処理して、対処できないエラーを上位のレベルへ渡す構造であり、この構造をサポートするのが `terminate()` である. これを使うと、`例外処理システム自体が壊れている`、あるいは、`不完全にしか動作しない`、などの理由によって例外が捕捉されないままとなった状態からの脱出が可能.
    - terminate が呼ばれる条件:
      - exception が捕捉されない場合. 換言すると、送出された例外に適したハンドラがない時 (it is implementation-defined whether any stack unwinding is done in this case)
      - `noexcept` が例外を行って終了しようとした時
      - exception をハンドル中に exception が捕捉されずに抜けてしまった際に、exception ハンドルメカニズムが使う(e.g. a destructor of some local object, or a copy constructor constructing a catch-clause parameter)
      - `スタック巻き戻し中`にデストラクタが `throw` を行って終了しようとした時
      - throw する例外がない（catch 節の外）のに再送出した時
      - a static or thread-local object のコンストラクタ（初期菓子）が exception を投げたとき
      - `std::atexit` or `std::at_quick_exit` で登録された関数が exception を投げたとき、など. 詳細は p381 を参照(381)
  - `noexcept`:　エラー回復が不可能と判断される場合に、エラー処理から脱出できる
  - `例外安全なコード`: あるコード内で実行中の失敗が、`メモリリーク`、`格納データの不整合`、`不正な出力`などの有害な効果を生じないこと
  - `資源獲得時初期化(Resource Acquisition Is Initialization: RALL)`: 局所オブジェクトを使った資源管理のこと(366), 具体的には、資源の'取得'を`クラス型変数の構築`（`初期化`）時に、また'返却'を`破壊時`に行う。特にプログラムの制御フローが`自動変数の属するブロックを抜けるとき`、その変数のデストラクタが自動的に呼ばれるため、デストラクタを適切に記述したクラス型変数の寿命が終わるとすぐに資源が返却されることが保証できるようになる。これは例外が発生したときでも同様
    - 資源管理には、`try-except`を使うのではなく、コンストラクタで資源を確保しデストラクタで確実に解放する`資源ハンドル`をすること
    - コンストラクタの途中で問題があった場合、部分オブジェクト(問題発生までに作成されたオブジェクト、完全オブジェクトではない)はデストラクタで確実に解体すること（`作成途中`の状態に置かないこと）
    - `二つ以上の資源`：この場合も、同様な方針でコンストラクタで資源獲得を行い、どちらか一方でも失敗した場合は `throw` するような仕組みで構築すると良い
  - デストラクタで例外を送出してはいけない.(372)
  - 捕捉した例外オブジェクトは、送出された例外オブジェクトのコピーである。すなわち、throw x; では、x 型の一時オブジェクトが　 x で初期化される。その一時オブジェクトは、捕捉されるまでに複数回コピーされることがある(373)
  - `スタック巻き戻し（stack unwinding）`: 送出された位置からハンドラまで、例外を`スタックの上方`へ渡す過程:
    - 構築されたオブジェクトは、スコープを抜けた時に解体される。また`スタック巻き戻しの過程で構築されたオブジェクト`は`作成された順の反対の順`で解体される
  - H から継承した Exception E の場合、H は`公開基底`という。この場合、E を `throw` した際には `catch(H) 節` で拾われる. 同じ条件下でそれぞれの型がポインター、または参照型でも実行される(376)
  - 例外に const を不可することもできて意味自体変化しないが、その例外自体を変更できなくなることを示すために使われる
  - `再送出（rethrow）`: catch 節以外の場所でやると `terminate()`. 再送出されるのは、catch された内容で、例え exception などの公開基底で catch しても元の例外が送出される. もし別の例外を送出したい場合は、throw My_error{} のように例外をつけて throw する. このように再送出の際に例の内容が変わることを`スライシング`という. スライシングを行うと、上方では元の例外を catch することができなくなる
  - 関数全体を try-catch にするメリット: コンストラクタでメンバの初期化に失敗した場合に、呼び出したところに throw するのではなく catch できる。ただ初期化しようとしたメンバオブジェクトが未構築であれば構築されることはないし、もし構築済みであればスタック巻き戻しの一環でデストラクタによって解体される。結局は最後に再送出することになる
  - 名前空間とスレッド局所変数の構築中あるいは解体中に送出された例外を捕捉する方法は存在しない. このことは広域変数を避けるべき理由のひとつである. (383)
  - あるスレッドが送出した例外を他のスレッドのハンドラに転送する処理は、標準ライブラリ関数 `current_exception()` によって行う
- `template`:

  - The difference between `typename` and `class`: in general no difference. typename is clearer to indicate it's type, not object.
  - [nested template1](https://stackoverflow.com/questions/20373466/nested-c-template-parameters-for-functions)
  - [nested template2](https://stackoverflow.com/questions/39078287/nested-templates-template-template-parameters)

- `allocator`: explicitly `allocate heap memory`, construct it, destroy it, and then finally deallocate the memory. (If you don't want to do that, don't use an allocator, use new instead.)

  - `you use an allocator when an allocator is required` (such as when using a container) and you use `std::allocator when you don't want to provide a custom allocator` and just want the standard one. You don't use an allocator as a replacement for `new` and `delete`.
  - `new` または `malloc` を使用すると、`メモリ管理`は`コンパイラのランタイムの対応する関数に固定`されるが、`アロケーター`が使用される場合、`メモリー管理`は`アロケーターに委任され、アロケーターは交換可能`である。これにより、使用するメモリ管理機能を変更することができる。
  - vector などの初期化した時に確保したメモリをその時点で全て使用するのではなく、将来のどのタイミングかで利用する時などに有効.
  - vector の場合、`reserve` すると初期化の時点で capacity をセットできるため、reallocation が問題であればこちらを使う.
  - vector は保持できるサイズ（`vector::max_size`）を超えると `length_error` を送出する `my_vector.max_size()` で確認する（基本的には膨大な値）
  - [Ref1](https://stackoverflow.com/questions/31358804/whats-the-advantage-of-using-stdallocator-instead-of-new-in-c)
  - [Ref2](https://cloud6.net/so/c%2B%2B/1348832)

- `explicit`:
  - Prefixing the `explicit` keyword to the constructor prevents the compiler from using that constructor for implicit conversions.
  - [Ref](https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean)
  - Compiler can use `constructors callable` with a `single parameter` to convert from one type to another in order to get the right type for a parameter.
  - `Single parameter` でなくても、`先頭の仮引数以外の仮引数にデフォルト値が渡されていている場合`も、`Single parameter` とみなされるため、`implicit conversion` が適用される. 例) `Object( const char* name=NULL, int otype=0).`
- `名前空間（namespace）`:
  - 名前空間内で宣言されている実体は、`名前空間のメンバ`と呼ばれる
  - `明示的修飾`: メンバを利用するときは、`完全修飾子`を使う: `namespace Text_lib{ class Graph { /* ... */}}` の時に Graph を使うときは `Text_lib::Graph`(400)
  - `using 指令`、`実引数依存探索`: namespace の外からある名前空間のメンバを利用する方法:
    - `using`:
      - `広域スコープ`はそれ自体が名前空間になる. `::` を使うと明示的に`広域スコープ`を参照
      - `using 宣言`: 同義語（ある名前空間のメンバ）を同じスコープ中に導入する(`using N::f;`). 多重定義や名前衝突が起こる可能性があるため、なるべく局所的に使う
        - class 内で `using` を使う手法もある(595)
      - `using 指令`: ある名前空間のメンバを全て同スコープ中に導入する(`using namespace std;`).
    - `実引数依存探索（argument-dependent lookup/ ADL）`(403):
      - 関数 C 内で呼ばれるある関数 F が同一スコープに見つからない場合、関数 C の実引数自体の名前空間が探索の対象となること。
      - その結果同じ関数名が複数見つかった場合: 通常の多重定義解決が行われる
        - この関数の探索は、`（通常通り）関数呼び出しのスコープ`、`全引数（クラスと、その基底クラス）の名前空間`から行われる
        - 一致度が一番高いものが選択されるため、期待してる関数が呼び出されないことがある. 例えば同クラスに同じ関数を定義しそれが呼び出されることを期待しているが、別の`関連名前空間`に定義されている同名の関数の方が引数の一致度が高く、そちらが呼ばれる可能性がある.
      - `関連名前空間(associated namespace)`: `実引数依存探索の規則`(404)
        - 引数がクラスメンバであれば、`関連名前空間`は、そのクラス自身（とその基底クラス）とそのクラスを囲む名前空間
        - 引数が名前空間のメンバであれば、`関連名前空間`は、そのメンバを囲む名前空間
  - 名前空間によってインターフェースと実装を分離する。さらにその場合、namespace 名は同じである必要はないため、`ユーザー用インターフェース`と`実装者用インターフェース`を分離すると良い(412)
  - `同名変数の衝突`:
    - `局所的に宣言された名前`（それが`通常に宣言されたもの`でも、あるいは、`using 宣言で宣言されたもの`であっても）は、同じ名前の非局所の宣言を隠す.(413)
    - 尚、上のように`局所的な宣言`を複数回行うことは不正である
    - また`非局所的な変数`が複数個あると曖昧エラーになる（広域と using 指令によって複数候補存在する場合など）
    - 上記の規則をうまく活用すると、合成(using 指令)と選択(using 宣言)によって宣言に必要な柔軟性を手に入れることができる(415). つまり、合成しつつもし名前で衝突した場合は、選択によって局所的に宣言して衝突を回避することができる. これによってさまざまな名前空間を組み合わせることが可能となる.
  - `名前空間別名`: 同じ名前空間に対して、型別名をつけられるのでバージョン管理が容易になる(414)
  - `インライン名前空間(inline namespace)` を使うことによって複数のバージョンを管理することができる(418)
- `コンパイル`:

  - `外部結合（external linkage）`: 定義した名前が別の翻訳単位でも利用可能であること
  - `内部結合（internal linkage）`: 定義した名前が翻訳単位内のみでも利用可能であること
    - `static` をつけると内部結合になり、`const`の変数は暗黙裏に内部結合になる. `const` を外部結合にする場合は、明示的に `extern` をつける.
  - `無結合（no linkage）`: リンカから見えない局所変数など
  - `inline 関数`の整合性を保証したい場合は、ヘッダを利用する（ヘッダに書いて使うところで読み込む）(428)
  - const オブジェクト、constexpr オブジェクト、型別名、名前空間スコープ内で static と宣言されたものは全てデフォルトで内部結合. そのためこれらを外部結合にしたい場合は、inline 関数と同様にヘッダに extern と宣言することで整合性保証と可読性を保つ.(428)
  - `ファイル内局所名`: `static` とするか、`名前無し名前空間`で宣言する(429)
    - `名前無し名前空間` とするとコンパイル単位だけの局所的なものとすることができる.
  - ヘッダに定義するべきものとすべきでないもの(431):
    - 定義するべきもの: `名前付き名前空間`、inline 名前空間、テンプレート宣言、テンプレート定義、型定義、など
    - すべきでないもの: 通常の関数定義、データの定義、集成体の定義（`short tbl[] = {1, 2, 3}`）など
  - `単一定義則（one-definition rule/ ODR）`: クラス、列挙体、テンプレートなどはプログラム内でちょうど１回だけ定義されなければならないこと
    - 別々のファイル（`異なる翻訳単位である`という）でも定義が全く同じであれば（`トークン単位で同一である`という）二重定義は問題ないが、通常は２回以上定義すると、一方のみ参照しているプログラマによって一方の定義のみ修正される可能性が出てくるのでヘッダで管理すること.
  - `C 結合`: C++ 以外のコードとの結合を分けるために使われる. `C 結合`の場合は C 言語に限らず Fortran やアセンブラルーチンに対して用いられることもある.(435)
    - `extern "C" ...`のように宣言する.
    - 結合同士の関数などの利用はできるが、言語を超える利用は基本的にはできない(言語拡張機能として認められるなどでエラーにならない場合もある)(436)

- `class`:
  - `物理的定数性`と`論理的定数性`(466):
    - `論理的定数性`: 論理的には const であるはずのメンバ関数が、データメンバの値を変更する必要に迫られることがある。その場合、ユーザには、オブジェクトの状態が変化しないように見える一方で、ユーザからは直接見えない細部が変更される
      - このような場合に `mutable` で修飾したデータメンバを変更することができる
      - または、変更される可能性があるオブジェクトを別オブジェクト内に置いた上で間接的に利用することもできる(467)
  - `自己参照`:
    - `this` は右辺値とみなされるため、アドレスを取り出したり、代入の対象にしたりすることは不可能である.
    - `非 static メンバの参照`は全て、適切なオブジェクトを得るために`暗黙裏に this を使用して呼び出されている`（これはオブジェクトがポインタである場合も暗黙裏に呼び出されている(`this->` が呼び出されている)）.(468)
    - `テンプレートである基底クラスのメンバ`を`派生クラスから利用する際`には、明示的に `this` を利用する必要がある.(469)
    - 特定のクラスのメンバを直接利用するときは `::` を使う. (`int (S::*) pmf() {&S::f};` 関数へのポインタをこのように表すこともできる)(470)
    - `static データメンバ`はクラス全体で１個だけ存在する。同様に `static メンバ関数`は特定のオブジェクトに対して呼び出す必要がない関数である
      - `static データメンバ` は競合が起こす可能性がある場合は、ロックなどのアクセス規則が必要である.
    - `入れ子クラス（nested class）, メンバクラス（member class）`: クラスの中に定義されるクラスであり、メンバクラスはそれを囲んでいる型と方が持つ static なメンバ、非 static なメンバ(private メンバも含めて)を利用することができる.(472)
      - 囲っているクラスからクラスメンバのメンバを参照することはできない.
      - クラスメンバから囲っているメンバを参照する場合は、引数にポインタで渡すとよい.(472)
  - `具象クラス`:
    - クラス設計も含め、そもそも設計とは、何らかの決断を下すものであり、決断を先延ばしにしたり、あらゆることをオプションとしてユーザに押し付けるものではない(476)
    - コンストラクタがクラスの不変条件を確立する。一旦オブジェクトが作成されるとそれは正当なオブジェクトとして利用できることを保証する(476)
    - メンバ関数はこの不変条件を維持するように努めなければならない
    - `ヘルパ関数`: 内部表現に直接関与しない関数はメンバ関数とせずに、ヘルパ関数とするとこでクラスインターフェースを簡潔化させることができる
    - Date のような`単純なユーザ定義型`を`具象型（concrete type）`と呼ぶ。`具象クラス`は、`組み込み型と同等`で、`値型（value type）`とも呼ばれ、それを利用したものは`値指向プログラミング（value-oriented programming）`と呼ばれる。これは、一般にオブジェクト指向プログラミング（object-oriented programming）とはまったく異なる.(480)
      - `具象型の目的`: 比較的単純な単一の処理を、効率よく的確に実行すること.(480)
      - 具象クラスからの派生では、仮想関数や実行時型情報が利用できないため、限られて場所で注意深く使うべきである(481)
  - `配置構文(placement syntax)`: 割り振られたス トレージ・ロケーションを指定して、そのストレージ（メモリ領域）にオブジェクトを作成する（new）方法(292)
    - [Ref](https://www.ibm.com/docs/ja/xl-c-and-cpp-aix/13.1.0?topic=only-placement-syntax)
  - `private な destructor`: スコープを抜けた時や delete された時に暗黙裏に destructor が呼ばれるが、この挙動を抑制する方法として、destructor を private に宣言することである(490)
  - `virtual な destructor`: 一般に仮想関数を持つクラスでは、デストラクタも virtual にするべきである. これは、基底クラスのインターフェースを通じて操作されるオブジェクトが、基底クラスのインターフェースを通じて delete されてしまう可能性があるため. 基底クラスのデストラクタが virtual でない場合、派生クラスのデストラクタが delete によって起動できなくなるため、削除したいオブジェクトがリークしてしまう.
  - `コンストラクタがない場合の初期化(struct)`: 初期化しない場合（`{}`, などでコンストラクタを呼び出さない場合）局所変数や秋領域に割り当てられたオブジェクトでは、クラス型のメンバのみがデフォルト初期化されて、組み込み型のメンバは初期化されない.(492) 例えば `struct Buf{ int count; char buf[16 * 1024]}; Buf buf1; Buf buf2;` では、buf1 は初期化されないので、局所変数は不定値（0 などではない）であるが、buf2 ではちゃんと初期化される.
  - vector などのコンテナを利用する場合で、値と個数の型が同じ場合（値が int の場合）や 0 を用いる場合の挙動はやや直感からはズレるため注意する(495) `vector<int *> v6 {0, 0}; // nullptr で初期化される 2 要素の vector`
  - 参照と const は初期化が必須である
  - 複数のコンストラクタが存在する場合には、`デフォルトのコンストラクタ`、その次に`初期化子並びコンストラクタ`が優先的に呼び出される(498)
  - 初期化子並びは変更できないし、ムーブコンストラクタに適用もできない. そのため、初期化子並びを書き換え等の初期値として利用したいときは、コピーする(`uninitialized_copy(s.begin(), s.end(), elem);`)(500)
  - `コピー初期化(copy initialization)`・`直接代入(direct initialization)`を区別する. よく利用されるコピー初期化では暗黙裏に型変換を行っている(`int a = {1};`) 一方で、直接代入では型変換は行っていない(`int a{1};`) この違いは explicit を用いることで顕著化する.(462)
    - また例えば、`vector<int> v = 1;` は暗黙裏に型変換を行おうとするが、`int -> vector<int>`の変換は存在しないのでエラーになるのに対し、`vector<int>{1};` は 1 を initializer_list の１要素として初期化を行うため問題ない。（また、vector などの複数の要素を受け取るコンテナの場合 `vector<int>(2)` とすると`デフォルトが 0 の 2 要素のメモリ確保`の意味になるため注意.）
  - クラスにデフォルトコンストラクタを与えるのは、`自然な`デフォルト値が存在する場合に限定する(527)
  - `メンバのコンストラクタ`:
    - クラス自身のコンストラクタ本体の実行前に呼び出される.
    - メンバの呼び出しの順序は、初期化子に記述した順序ではなく、クラス内でメンバを宣言した順序になる.
  - `メンバのデストラクタ`:
    - クラス自身のデストラクタ本体の実行後に呼び出される.(コンストラクタと逆)
  - コンストラクタは、メンバの基底、メンバのメンバ、基底のメンバ、規定の規定などの初期化は行えない(502)
  - `初期化子による初期化`と`代入による初期化`の両方を行うことができる
    - `代入による初期化`では、いったんメンバをその型で初期化した後で引数を代入することで初期化される(503)
  - `基底クラス`:
    - 基底クラスの初期化はメンバより先に初期化されてメンバの後で解体される.
  - `委譲コンストラクタ（delegating constructor）/ 転送コンストラクタ（forwarding constructor）`: 複数コンストラクタを宣言し、メインのコンストラクタに処理を委譲するような他のコンストラクタのこと(504)
  - `クラス内初期化子`: 複数コンストラクタで初期化するクラスのメンバであれば、局所的に初期化をすることができる. (506)
  - `クラス宣言内で static メンバの初期化は基本的にはできない`が、`const な汎整数型`あるいは`列挙体`、または、`constexpr なリテラル型`であれば初期化可能である. (507)
  - `基底のコピー`: `コピー演算においては基底は単なるメンバにすぎない`. コピー演算では全メンバをコピーする必要があるため、派生クラスのオブジェクトのコピーではその基底もコピーする必要がある.
    - 基底をコピーするには引数に渡された派生クラスのオブジェクトで基底クラスの初期化をすれば良い. (511)
  - `浅いコピー`: コピーオンライトと `shared_ptr` を上手く使うと効率の良いコピーを実装することができる(514)
  - `スライシング`: `派生クラスを指すポインタ`は、その`公開基底クラスへのポインタ`へと暗黙裏に変換されること
    - スライシングされた時には、派生クラスのメンバは利用できなくなり（アクセスできなくなり）、公開基底クラスをしかアクセスできなくなる.
    - スライシングを防ぐ 3 つの方法:
      - 基底クラスのコピー禁止: コピー演算を `delete`. その代わり、close() 関数が必要になるかもしれない (17.6.4)
        - `関数の delete`を利用する他の目的(525):
          - 例えば、クラスをメモリ上に割り付けられることの制御として使用. (この場合、デストラクタを`=delete`すると、"解体できないオブジェクトは空き領域に割り当てられない"ためインスタンス化できなくなる. ただし new で作成することはできる(17.2.2))
      - 派生へのポインタを基底へのポインタへ変換できなくする: 規定クラスを private もしくは protected にする (20.5)
      - コピー演算を private, protected と宣言した上で、スライシングを伴わないコピーが可能となるように close() 関数を実装する (20.3.6)
  - `デフォルト演算の生成の規則`:
    1. プログラマがクラスのコンストラクタを１個でも宣言すれば、コンパイラはデフォルトコンストラクタを生成しない
    2. プログラマがコピー演算、ムーブ演算、デストラクタのどれか１個でも宣言すれば、コンパイラはコピー演算、ムーブ演算、デストラクタを一切生成しない
    - しかし、後方互換性維持のため`デストラクタを作成してもコピー演算、ムーブ演算が生成されてしまう`(519)
  - `明示的な default`: `=default` とすることで、コンパイラが自動で生成する演算をデフォルトとして使用することを明示的に示すことができるが、挙動は等価で単に冗長的であるので避ける方が良い
  - `メンバにポインタを持つ場合`: 危険である
    - 複数のオブジェクトが同じポインタの場合、デフォルトのデストラクタはメンバのポインタを二重に delete してしまう可能性がある(523)
  - `メンバを指すポインタのメンバを持つ場合`: 危険である
    - そのオブジェクトを move した時には、ポインタを指すメンバのアドレスは変わるため（関数から返した時、初期化した時のポインタのアドレスが move によって変わる）古いアドレスを指しているメンバは新メンバがいるアドレスとは別のアドレスを指すこととなる(522)
  - クラスが仮想関数を持つのであれば、仮想デストラクタも必要である.
- `演算子(演算子関数)の多重定義`:
  - 新しい演算子トークンは定義できない. 定義できる演算子は 531 を参照.
  - `operator ""()`: ユーザ定義リテラルが定義
  - `operator T()`: 型 T への型変換を定義
  - 演算子を利用するのは、明示的な演算子関数呼び出しの省略形にすぎない `void f(complex a, complex b) { return a + b; } // 省略形` `void f(complex a, complex b) { return a.operator+(b); } // 明示的に呼び出す`
  - `二項演算子`: `@` を演算子とすると、`aa@bb` は `aa.operator@(bb)` または、`operator@(aa, bb)` のいずれかに解釈される
    - 両方定義したときは`多重定義解決法則`によって解決される(532)
  - `単行演算子`:
    - 前置単行演算子を `@` を演算子とすると、`@aa` は `aa.operator@()` あるいは、`operator@(aa)` と解釈される
    - 後置単行演算子を `@` を演算子とすると、`aa@` は `aa.operator@(int)` あるいは、`operator@(aa, int)` と解釈される
  - `演算子の探索`: 二項演算子が `@`であり、`x` が `X` 型オブジェクト、`y` が `Y` 型オブジェクトであるとき、式 `x@y` は次のように解釈される(536):
    - 演算子の探索において、メンバが非メンバより優先されるということはないし、広域の演算子関数が局所関数によって隠れてしまうということはない(537)
    1. X がクラスならば、X のメンバとしての `operator@`、あるいは、X の基底のメンバとしての `operator@ `を探索
    2. `x@y`を囲む文脈の中で、`operator@` の宣言を探索
    3. X が名前空間 N で定義されていれば、`N` 内で `operator@` を探索
    4. Y が名前空間 M で定義されていれば、`M` 内で `operator@` を探索
- `メンバにするか、非メンバにするか`:
  - 第一引数の値を変更するような演算子はメンバ(+=): `内部表現へのアクセスが必要となるため`
  - 引数を元にして別の値を作るだけのような演算子は非メンバ(+)
- `混合算術演算（mixed-mode arithmetic）(Fortran の定義による)`: z が `complex` であるときに `2+z` を正しく扱うためには、`+演算子`が左右の型が異なるオペランドを受け付ける定義が必要である. (539)
- `混合算術演算で発生する組み合わせの数の爆発的増加を封じ込める方法`: 暗黙的な型変換を利用する. 引数型と適用可能な変換（`標準型変換`と`ユーザ定義型変換`）(541)
- `ユーザ定義リテラル`: 例えば`constexpr complex<double> operator "" i(long double d)` のように `i` に対してリテラルを定義すると `12e2i` が 1200 を虚部として持つ complex オブジェクトに変換することができる(543)
- ユーザ定義型の暗黙の変換は、１段階のみが認められている(547)
- 型変換に複数の候補が存在する場合、組み込みの型へ変換変換できる場合は、ユーザ定義型に優先して採用される(548)
- `特殊な演算子`:
  - アロー演算子(`->`)は多重定義できるが、ドット演算子(`.`)はできない(556)
  - アロー演算子の返却値は、ポインタであるか ` ->` が適用可能なクラスでないといけない(556)
  - インクリメント、ディクリメント：前置・後置の区別(557)
    - 前置: インクリメントの実装の場合、ダミー引数を持たずに参照を返す++ すなわち `int& operator++()`
    - 後置: 後置であるダミー引数を持ち演算結果前の古い値を値渡しで返す++ すなわち `int operator++(int)`
  - `テンプレートリテラル演算子(template literal operator)`: 関数ではなく、テンプレートパラメータパックを引数に受け取るリテラル演算子(561)
- `フレンド(friend)`: 他のクラスの内部要素にアクセスすることができる
  - フレンド関数は他のクラスのメンバ関数でも可能. `friend int* List_iterator::next()`(573)
  - あるクラスの全てのメンバ関数を別のクラスのフレンドとするための省略記法もある `friend class List_iterator;`
  - PHP の trait のような感覚で利用できる.
  - テンプレート引数を friend にすることもできるため、必要に応じて利用するメンバ関数を切り替えることができる `friend T; // class を T の前につける必要はない` (574)
  - フレンド関係は継承されないし、その関係が連鎖することもない(684)
    - 例えば、`C` が `My_class<int>` のフレンドであるとして、`My_class<int>` も `My_other_class<int>` のフレンドだからと言って、`C` が`My_other_class<int>`のフレンドになることはない.
  - `フレンドの探索`:
    1. 同一スコープ内で、事前に宣言
    2. friend を宣言するクラスがいるスコープの外で宣言（事前に宣言する必要がない）
    3. 一番内側のスコープ外は事前に宣言する必要がないが、それよりも広域のスコープ（２スコープ以上外）の場合は、やはり事前に宣言しておく必要がある
    4. スコープ内場合でも、フレンド関数を持つクラスのインスタンスを引数にとることで、インスタンス経由でフレンド関数を探索することができる(引数に何も取らないフレンド関数の場合は探索しようがないためエラー) (575)
- `引数の変換`:
  - `非 const 参照引数`が暗黙裏に変換されることはない (-> 非 const なので、参照先のオブジェクトを変更することを期待している) -> `メンバ関数`とすべき（`演算子 = *= ++`）
  - `const の参照`, `値渡しの引数(非参照引数)`は暗黙裏に変換される -> 暗黙裏に型変換を期待する関数は、`非メンバ関数`とすべき (演算子 + - ||）(576)
  - 演算子 + - || は内部表現にアクセスする必要がでてくることも多く、その場合に friend とする
- `継承`:
  - `主な手法`:
    - `インターフェース継承`：`実行時多相性（run-time polymorphism）`, `動的多相性（dynamic polymorphism）`と呼ばれる
      - メンバ関数に virtual をつけることで実現する
      - オブジェクトのアクセスにポインタや参照経由で直接アクセスするときは、コンパイラは型がわかっているため`実行時多相性（run-time polymorphism）`は不要である(virtual を付けずに単に規定クラスの関数をオーバライドするだけで良い)
      - コンストラクタやデストラクタの中で仮想関数を使用は避けるべきである:
        - 部分的に構築、解体された状態だと想定している仮想関数が呼ばれない可能性があるため.
    - `テンプレート`: `コンパイル時多相性（compile-time polymorphism）`、`静的多相性（static polymorphism）` と呼ばれる
  - 派生クラスのオブジェクトは、ポインタと参照を経由して利用された場合にその基底クラスのオブジェクトとして処理される. ただしその逆は成立しない(582)
  - 派生クラスは規定クラスの private にアクセスできない：
    - メンバ関数、フレンド関数を見るだけで内部表現がどのように操作されているか把握できるようにするため.
    - プログラマはクラスを継承するだけで内部表現にアクセスできてしまうため
  - どうしてもアクセスが必要であれば、限定公開メンバとして宣言する
  - 基底クラスのメンバにアクセスする場合は、`規定クラス名::member` とする `Base::print()`:
    - `::`: スコープ解決演算子
  - `継承を最大限に活用する`: ポインタ型を与えられたときにそれがどの派生クラスを指すのかを明確にできるようにする:（585）
    1. ポインタが指す型を、ある単一型のオブジェクトに限定する
    2. 関数が判断できるように、規定クラス型フィールドを持たせる
    3. `dynamic_cast` を利用する
    4. 仮想関数を利用する
  - `型フィールド`を用いることの問題(586)：
    - 基底クラスが持つ公開関数が派生クラスが増えるごとに、また機能が増えるごとに無限に肥大化してしまうため、変更箇所が広域になってしまうかつテストするためのオーバーヘッドが避けられなくなる.
    - 型フィールドを使う場合、派生クラスを追加するごとに派生クラスのための型を型フィールドの追加する必要があり、規定クラスがクラスではなく広域の変数定義のための領域になってしまう(広域変数).
    - 型フィールドによる問題を解決するのが`仮想関数（virtual function）`である
  - `オーバライド制限`:
    - `virtual`: 派生クラス先でオーバライド可能である
    - `=0`: 関数は virtual であって、派生クラス先で必ずオーバライドしなければならない
      - `純粋仮想関数(pure virtual function)` と呼ぶ. `=0` をつけることを`純粋化する`という
      - `純粋仮想関数` を一つでも保有するクラスを`抽象クラス`という
        - `抽象クラス`はオブジェクト化することができない
        - `抽象クラス`を用いた設計スタイルを`インターフェース継承(interface inheritance)`と呼ぶ(601)
    - `override`: 派生クラス先で基底クラスの仮想関数をオーバライド
      - override はキーワードではなく、`文脈依存キーワード（contextual keyword）`と呼ばれるもので、クラス外で利用することはできない
        - override が文脈依存キーワードな理由は、override を普通の識別子として利用するコードが大量に作られてきたためである → 識別子と使用することを許可している.（例えば、override, final を変数名として使用することがきる.）
        - 他の文脈依存キーワードは final . final も同様にクラスの外で使用することができない
    - `final`: 派生クラス先でオーバライドすることができない
    - 上記の制限を全く用いなければ、基底クラスの virtual 関数をオーバライドする非 static メンバ関数は仮想関数になる(592)
  - ベストプラクティス: 仮想関数を追加するときには、virtual を利用して、オーバライドしようとする側では override を利用する
  - 言語のセマンティクスが変更されてしまっては困るクラス、一旦設計を閉じなければならない場合は仮想関数とすべきではない. (593)
  - クラス名の後ろに final をつけるとクラスの仮想関数は全て final となる. `class For_statement final: public Node{ ... }`. さらに、final されたクラスから派生することはできない.
  - `using 宣言`を使うと基底メンバを派生先の名前空間に持ち込むことができる. 関数多重定義解決では、基底メンバ一致度が最も高い場合それが選択されることになる.
  - `using 指令`で基底クラスの全メンバを持ち込むことはできない.
  - `仮想コンストラクタ(virtual constructor)`: virtual であって、しかも（間接的に）オブジェクトを構築する関数(599)
    - 適切なオブジェクトを作成するには、その正確な型をコンストラクタが知っておかなければならない . そのため、virtual にはなれない. さらに、コンストラクタを指すポインタを取り出すことはできないし、そのポインタをオブジェクト作成関数に渡すこともできない. そのため、オブジェクトの作成には仮想コンストラクタを使用する.
  - `protected`: 基底クラスに限定公開データを集約してしまうことに繋がったり、それがどのように変更されるのかについて全ての利用箇所を探し出すのが困難になることがあるため保守上の問題に繋がりやすい. 幸いなことに、限定公開データを利用する必要はない.
    - `限定公開関数`は上記の問題には当てはまらない. (606)
  - `仮想デストラクタ(virtual destructor)`: 基底クラスが派生クラスへのポインタを指すときに、基底クラスを削除 (delete)すると、規定クラスのデストラクタは呼ばれるが、派生クラスのデストラクタは呼ばれないためリークする. 派生クラスのデストラクタを呼びたい時には、仮想デストラクタにして、派生先でオーバライドする.
    - If you want to prevent the deletion of an instance through a base class pointer, you can make the base class destructor `protected` and `nonvirtual`; by doing so, the compiler won't let you call `delete` on a base class pointer.
    - [Ref](https://stackoverflow.com/questions/461203/when-to-use-virtual-destructors)
  - `メンバへのポインタ`: `->*`や `.*`を使って、メンバ関数をポインタ経由で呼び出す手法:
    - `p->*m`: ポインタ p が指すオブジェクトにメンバ m を結びつける
    - `obj.*m`: オブジェクト obj にメンバ m を結びつける
    - 通常のポインタとは違う.
      - static なメンバはメンバへのポインタになりえない.
    - メンバ関数へのポインタは、関数名が不明な場合に利用される
    - `通常のポインタとメンバへのポインタのセマンティクスの違い`:
      - `通常のポインタ`: `void(*p)() = &Task::schedule;` 関数 schedule へのポインタを p へ代入
      - `メンバへのポインタ`: `void (Task::* pm)() = &Task::schedule;`
  - `反変性(contravriance)`: 規定クラスのメンバを派生クラスのメンバへのポインタ経由で変更することは安全であるが、その反対は安全でない. この性質を`反変性`という.
    - 「ポインタは、そのポインタをさすために必要な最小限の性質を持っていないオブジェクトは指さない」という基本的な原則に従うと、規定クラスのメンバへのポインタへ、派生クラスの関数へのポインタを代入するということは実行時エラーにつながる.(612)
    - `void (Base::* pmb)() = &Derived::print; // error`: Base は print を持たない
    - `void (Derived::* pmd)() = &Base::start; // ok`: Defived は間違いなく start を持つ
- `クラス階層`:
  - `実装継承`:
    - 基底クラスに固有のドメイン名を使用しないこと. 多くのバージョンを作成したいなら名前空間に宣言したり、別のクラスとして置いておくなど規定クラスの上のクラスとして設計しないようにする(616)
    - 基底クラスに限定公開データを用いない(616) :
      - 無関係のデータを持たせてしまい混乱の原因になる
      - 基底クラスの変更があった場合、全ての派生クラスを再コンパイルしないといけない
      - クラス実装者に自由にアクセスさせたいなら、派生クラスで自由に宣言して利用させる
  - `インターフェース継承`:
    - `多重継承（multiple inheritance）`: あるクラスからは実装を継承して、別のクラス（抽象クラス）からはインタフェースを継承する、というのは継承や、コンパイル時インタフェースチェック機能がある全ての言語にとって一般的である(619)
    - 通常は、より限定的なクラスを実装階層内に導入すると実装が改善される(621)
      - これにより限定的なクラスをオリジナルの基底クラスを含めたクラス階層を汚さないで構築することができる
      - 多重継承した際の同名の関数を派生先で解決するには、override せずに同じ型を持つ同名を再定義する。そうすると基底クラスの全ての関数をオーバライドする.(628)
      - もしセマンティクスが全く異なる関数で（例えば、draw 関数で一つは画面に描画する関数、もう一方はカーボーイが拳銃ケースからガンを抜く関数）複数継承した場合は、スーパークラスと継承先クラスの間にインタフェースそうを追加することで解決する(629)
  - `基底クラスの反復`: 複数の基底クラスの仮想関数は、対応する基底クラスの関数を呼び出して、その後に派生クラス独自の処理を実行する `f(){ A::f(); B::f(); cout << "Derived::f()" << endl; }`. 別々の関数としてオーバライドしたい場合は、上記の方法でレイヤを挟むようにする. (632)
  - `仮想基底クラス`: 基底クラスが同じである場合、デフォルトだと同じ基底クラスは別々のオブジェクトとなる. 問題なのは、ストレージ管理するようなクラスで同じファイルパスを持っていている際に、別々なオブジェクトがそれぞれ同じ書き込みを実行してしまうようなことがある. これを解決するために `仮想基底クラス` を用いて、同じ基底クラスは同じ１つとして派生するようにする. こうすることで共有が必要なクラスを一つにすることができる.
    - `仮想基底クラス` のコンストラクタは１度だけしか実行されないことが保証される
    - `仮想基底クラス` のコンストラクタは`最派生クラス`で実装しなければならない. これは、どのスーパクラスがすでに実装済みであるかどうかにかかわらずで、それは最派生クラス以外どの実装を優先して実行すればよいか曖昧だからである.(635)
  - `仮想基底クラスメンバを１回だけ呼び出す`: 仮想規定をそれを呼び出す関数でラップし、派生先で直近のスーパクラス(`直接規定クラス`)のラップ関数を呼び出すようにする.(636)
    - 仮想基底クラスのコンストラクタと同様に、仮想基底クラスのメンバは１回だけしか呼び出されない.(635)
  - `仮想規定関数のオーバライド`: 派生クラスは、直接基底、間接基底の仮想関数をオーバライドできる.
    - 異なる２つのクラスが、同じ仮想基底の別々の仮想関数をオーバライドするとそれらの派生クラスはその両方を継承しないと、クラス階層ないで同じ関数をオーバライドしようとした時にエラーとなる.(639)
      - 仮想基底クラスの、全部ではなくて、一部のみを提供するクラスは、`ミックスイン(mixin)`と呼ばれる.
- `実行時型情報（Run-Time Type Information, RTTI）`:
  - 一般に、クラスは、基底クラスの束で構築されるため、`クラスの束（class lattice）`はクラス階層(class hierarchy) と呼ばれる.
  - ダウンキャスト(downcast): 規定クラスから派生クラスへのキャスト
  - アップキャスト(upcast): 派生クラスから規定クラスへのキャスト
  - クロスキャスト(crosscast): 規定クラスから兄弟クラスへのキャスト(643)
  - `dynamic_cast`: dynamic_cast はコンパイラが型の正当性を判断できない変換に対応するために使用する
    - クラス階層を移動しなければならない時に利用(663)
    - dynamic_cast は設計の観点に立てば、`ある特定のインタフェースを提供しているかどうかをオブジェクトに問い合わせるメカニズム`とみなせる.
      - dynamic_cast の対象は多相体でなければ、キャスト後は意図する型へ復元はできない(650)
      - dynamic_cast を用いたインタフェースの復元手法は (652) を参照.
    - 非公開基底クラスと限定公開基底クラスに対する保護を勝手に破ることはない(これに対してアップキャストしない)
    - キャストに失敗した場合、エラーを送出するのではなく nullptr を返す
    - nullptr をキャストしようとした場合も nullptr を返す
    - 部分オブジェクトが一意となる基底クラス T を構成している場合、T へのアップキャストは失敗する (643)
    - `ダウンキャスト、クロスキャスト`: 適応する対象オブジェクトは多相体のポインタか参照でなければならない. (つまり、仮想関数を持つクラス)(644)
    - dynamic_cast を適用できるのは、多相体に限定されている
      - dynamic_cast の変換先の型は多相的である必要はない. そのため、具象型を dynamic_cast にかけたいときは、一旦多相体で包んでおいた後で包解いて具象型を取り出す、ということができる(644)
    - `void*`への型変換を行うと、多相型オブジェクトの先頭アドレスが得られる(645)
      - 派生クラスオブジェクトの内部に入っている、基底クラスを表現するオブジェクトは、最派生クラスオブジェクトの内部で、先頭部分オブジェクトである必要はない. そのため、`void*` で dynamic_cast で先頭アドレスにキャストした際にその前後で指すポインタのアドレスが同じであるとは限らない(645)
    - アップキャストじの仮想基底でも曖昧さが発生するが、これはコンパイル時に検出できる. 通常の規定であれば、ダウンキャストは１つまたは０つのオブジェクトに解決される(解決できない例として、`src/archives/abstraction/rtti/cast/basics.cpp` を参照)(648)
    - dynamic_cast が導入される前は、C 言語スタイルのキャストが用いられており、可能な限りより安全な dynamic_cast を用いる方が良い
    - コンパイラは `void*` が指すメモリ領域に対しては、何らかの想定をすることができない. そのため、このようなタイプのキャストには `static_cast `が必要となる
      - `Radio* (void* p){ Storable* ps = static_cast<Storable*>(p); // プログラマを信頼 return dynamic_cast<Radio*>(ps); }`
    - dynamic_cast, static_cast はいずれも `const とアクセス制御の効果を維持する`. つまり、これらを使って非公開基底クラスへのキャストを行うことはできないし、const を除去するキャストはできない.
      - const を除去するキャストでは、const_cast が必要
      - `reinterpret_cast` を使っても公開基底クラスへのキャストを行うことはできない
  - `ダイナミックディスパッチ（実行時探索、dynamic dispatch）`：
    - ２個の動的な型を用いる実装を表す場合に利用
    - 「一度に一つの型」を実現する（一度に一つの型を解決する）
    - 複数の動的型に対して一個の関数を選択できなければ、それは大きな制限となってしまう. しかも、仮想関数はメンバ関数でなければならない. そのため、インタフェースを提供する基底クラスとその影響を受ける全ての派生クラスを変更しない限り、クラス階層に対して仮想関数を追加するのは不可能である.(653)
      `ダブルディスパッチ`: ２つの型に対して仮想館煤を選択する手法:
      - ダブルディスパッチはぎこちないため、解決すべき問題の重要度は下がらない
        - 数多くの回避策があり、例えば、長方形どうしの交差は単純かつ効率よく判別できるため、円や三角形を長方形として表現してから交差判定を行うなどがあげられる. (655)
      - `Visitor パターン`: 階層に１個の仮想関数を追加するだけでクラス階層に対して複数の関数を追加するというダブルディスパッチを実現する手法
        - 抽象構文木（AST = abstract syntax tree）ベーツのツールで一般的に使われている手法.
        - グラフ内の異なる型の複数のノードにアクセスする処理には、ビジターは容易に実装できない.
        - 同じデータ構造を明示的に繰り返して処理するという方針の手法の方が良い.(27.4.2 を参照) (657)
  - `typeid`:
    - `typeid`のオペランドが、`nullptr `を値とする多相型を指すポインタや参照であれば、`std::bad_typeid` 例外を送出
    - `typeid`のオペランドが、`非多相型`の場合や`非左辺値`であれば、その結果はオペランドの式を評価することなくコンパイル時に決定される.
      - `非多相型`の場合は、最派生クラスを渡しても、その基底クラスの型を返すのに対し、ポインタや参照に対して参照外しを行った結果のオブジェクトが`多相型`の場合は type_info はそのオブジェクトの最派生クラスの型を返す
      - type_info オブジェクトはコンパイル後に１だけ存在するという保証はない(659)
        - そのため、比較には type_info オブジェクトが指すポインタに対する == ではなく、type_info オブジェクトに対する == を利用しないといけない(660)
  - `RTTI` を悪用しないようにする:
    - ヘルパ関数内で typeid や dynamic_cast で取得した型に対して条件分岐する(= あるオブジェクトに対して、どのインタフェースが実際に利用されるのかには依存せずに、同じ処理を行えるようにする(663))のではなく仮想関数を利用する.
      - その際にはこのヘルパ関数は virtual となり、それぞれの派生クラスで override することになる.(662)
    - 単一の型を扱う場合に利用しない. 冗長的になるし実行時のオーバヘッドもある.
- `テンプレート（template）`:
  - `クラステンプレート`は、テンプレート引数を導出することはできないが、`関数テンプレート`は、その関数の引数からテンプレート引数を導出できる. そのためテンプレート引数を `<>` で渡す必要がない.(808)
  - `具現化位置(point of instantiation)`: テンプレート引数に関するエラーでもっとも早期に検出できるのは、特定のテンプレート引数を与えてテンプレートを初めて利用する箇所である。初めて利用する箇所のことを`具現化位置`という. (675)
  - テンプレートのメンバ関数は `virtual` になれるが、`仮想メンバ関数`は`メンバ関数テンプレート`にはなれない(677)
  - `メンバ型別名`: テンプレート引数名は、テンプレート内飲みでアクセス可能であるため、要素の型を他のコードから参照できるようにするためには別名を提供しなければならない.(677)
    - `メンバ別名`としての型名は、一般に`関連型(associated type)`と呼ばれる
    - クラスが、必要となるメンバ別名を持っていなければ、`特性`でも代用できる(677)
    - クラスと同様にクラステンプレート内で `static データメンバ`を宣言するときは `const`, 外で宣言するときは `const 無し`で実装する必要があり、`static メンバ関数`は `constexpr`、外で宣言するときは、`constexpr 無し`で実装する必要がある.
      - また static メンバは実装されていなくても、実際に利用されていなければエラーにはならない(678)
  - テンプレートの前引数に本当に依存しないものは、テンプレート内で入れ子型にすべきではない. これは、コードの不要な銃属性を排除する一般則の特殊な例である
    (682)
  - テンプレートクラスのフレンド関数名の後ろには `<>` をつける
  - テンプレートを直接的にクラスのフレンドにすることはできないが、別に実装されたテンプレートをクラスの中で friend をつけてフレンドにすることはできる(684)
  - クラステンプレートの引数は導出されることがない. 複数のコンストラくたをモテるというクラスの柔軟性が、多くの場合における導出を不可能にして、さらに多くの場合に置いて導出を曖昧にしてしまうため. その代わりとして、特殊化がテンプレートの複数の定義の中から、暗黙裏に選択する仕組みを提供する.(686)
  - 右辺値と左辺値は、テンプレート引数の導出では区別される. `T` 型の左辺値は `T&` として導出されるのに対して、右辺値は `T` として導出される.
    - これは、非テンプレート引数の右辺値参照への値バインドとは異なる. (688)
  - 具現化の文脈を細かく制御する必要がある場合は、`明示的具現化`や、`extern template` を利用(697)
  - テンプレートとは何のためのものだろうか？(699): `ジェネリックプログラミング（テンプレートを使って実装された汎用アルゴリズムの設計に重点を置くもの）`をサポートするため.
    - 情報を損なわずに、引数に対して型を（さらには値とテンプレートも）渡せるため、インライン化の機会が飛躍的に増加する
    - 型チェックを遅延する（具現化時に行う）. そのため、異なった複数の文脈の情報を考慮する機会が生まれる
    - 引数として定数を渡せる. そのため、コンパイル時計算が行える
  - 生成的なテクニックにもっと特化して、コンパイル時算出される型関数を前提としたものは、`テンプレートメタプログラミング(template metaprogramming) `と呼ばれる(699)
  - `コンセプト`: テンプレートのコードが、その引数型に対して何を想定しているかを規定するもの (704)
    - 数多くのテンプレートと数多くの引数型に適用可能な、少数の`コンセプト（concept）（要件一式）`を特定するようにする.
      - 「物理的なプラグとソケットに似ている: 誰もが、最小限の手間で開発者の人生をシンプルにして、設計と構築のコストを低く保ちたいものだ. 」(708)
        - この願望は、汎用アルゴリズムの実装や、一部のプログラマが彼らの権利と考える'好きなように'コードを記述すべきであるという考えと衝突する(709)
    - 実世界での`プラグ互換`の一種のような、少数の標準プラグ設計が理想である.
      - 実装に対して正確に一致する引数要件一式をもったアルゴルリズムは、特化されすぎていて安定的に利用できない(705)
        - 引数型を実装する者にとって重荷になる
        - 引数として使える型を制限する事になる(汎用的でなくなる)(707)
          - 制約が多く、一つの実装における一つの利用法に必要な詳細のみ反映しているコンセプト（コンセプトにはなれないが）を`制約(constraint)`、 `その場限りコンセプト(ad hoc concept)`と呼ぶ
            - インタフェースの不完全な（部分的な）仕様化は何も仕様化されていない場合に比べれば良い(709)
          - コンセプトか制約かを判断する場面では、'略式なセマンティクスを明文化できるか?'と自問自答することが効果的で、理にかなったセマンティクス仕様を明文化できればコンセプト、できなければ制限である(709)
    - `コンセプトの具象化`:
      - コンセプトは、constexpr 関数として実装し、`static_assert()` や `enable_if<>` で確認する
      - 型と値一式のコンセプトをチェックする constexpr 述語の呼び出しのことを`制約判定(constraint check)`という.
      - 制約判定は関数であるが, 大文字から始めると良い(711)
      - `制約判定の弱点`:
        - 本来は宣言に所属すべきが、定義内に置かれることになる. これは抽象化へのインタフェースではなく実装部分でしか利用できないということである.
        - 実装の一部なので、コンパイラが初めてチェックするのは具現化された時である.
        - 実装内部で、制約条件を満たした性質だけ利用しているかどうかのチェックはないため、型チェックの段階でエラーとなることがある
          - 例えば、list の反復子を加算してその反復子に代入するようなことが起こり得るかもしれない(前進反復子の利用を想定していた.)(718)
          - テンプレートの制約判定は、引数を渡して利用するユーザに対しては助けになるが、実装者の助けにならない
            - このため`原型（archetype）`という強力なガイドラインを提供すること:
              - 「実装はコンセプトが指定していない引数の性質を一切利用しないようにするべきで、実装のテストはそのコンセプトのみ行う」(718)
        - セマンティクス上の性質は、コンパイラが理解できるようには指定できない（そのためコメントを利用するしかない）
      - `値コンセプト`: テンプレート引数は整数値を受け取ることもできるため、コンセプトも整数引数を受け取ることができる. (716)
  - `特殊化`:
    - `型仮引数(type parameter)(型の型)`: テンプレート引数を、typename や class の後ろに置いて定義されている引数
    - `値仮引数(value parameter)`: 整数とポインタを関数に与えるための仕組み. 整数引数は定数でないといけない.
    - `引数としての処理`: map や sort などの比較処理にラムダを用いることができる
      - ラムダ式を直接渡すことは、ラムダ式から関数オブジェクト型への嫌韓が存在しないため、エラーとなる. そのため一度変数へ宣言しておいて、その変数を `decltype` を通して渡すと良い(727)
    - `ユーザ定義特殊化（user-defined specialization）または、単にユーザー特殊化(user specialization)`: テンプレートの代替実装をあらかじめ定義しておき、実際の利用時に与えられたテンプレート引数に基づいて、コンパイラに選択させることができる. この代替実装のことを`ユーザ定義特殊化`という.(730)
    - `完全特殊化(complete specialization)`: Vector などテンプレートの型に複数種類の型を与えると、コンパイル時に膨大なコピーが作成されてしまう。これを解決するのが`完全特殊型`で、`void *`を使用し`Vector<void *>`と記述する.
      - それを用いた'ポインタ専用'の`部分特殊化(partial specialization)`(テンプレート引数を含むパターンによる特殊化)は以下のように記述する:
        - `template<typename T> class Vector<T*>: private Vector<void *>`
        - ここでパターンとは、特定の型のことである.
        - `Vector<T*>` は派生とインライン展開によって１個のものとして実装された同一インタフェースとなり、全てのポインタの Vector が実装を共有する. (732)
        - `タイプイレージャ(type erasure)`: このように複数の型の値に対して、単一の実行時内部表現を用いることで、宣言した型だけが利用可能となっている静的な肩システムを前提とするテクニックの変形のこと(732)
    - `関数テンプレートの特殊化`: テンプレート関数に対しても適用できるが、関数は多重定義できるので特殊化を行うことは少ない.(736)
      - 関数の完全特殊化のみサポートし、部分特殊化が必要であれば多重定義を用いる
  - `テンプレートの具現化`:
    - デフォルトでは、コンパイラは名前バインドの規則にしたがって、テンプレートからクラスと関数を生成する(742)
    - テンプレートクラスは、定義が実際に必要とならない限り、具現化'されない': ここで'必要となる'というのは、`実際に関数が呼ばれたり`、`そのアドレスが取り出される`ということである
    - `名前バインド(name binding)`: テンプレートを宣言したときにテンプレートに必要な型を解決する仕組み:
      - [IBM docs](https://www.ibm.com/docs/en/zos/2.2.0?topic=only-name-binding-dependent-names-c)
      - 定義が実際に必要とならない限り、'具現化'されないため、必ずしも宣言時にスコープに入っている必要がなく、具現化する時に解決できれば良い.
      - 宣言時に解決できない型を`従属名(dependent name)`という. + オペランドなども`テンプレート引数 T` によって実装が異なるため、従属名となる. -> 具現化時まで解決を遅らせる(この具現化される位置を、その処理の通り`具現化位置`という.)
      - これに対して、テンプレート引数に依存しない名前を `非従属名(nondependant name)`という.-> その場で解決. その場で解決するため宣言後により最適にマッチする関数を定義しても、選択されない. (746)
      - 従属名は、デフォルトで型`以外`のものに対する名前であると仮定されるため、型として利用する場合は typename で修飾する(`Value_type` などの汎用テンプレート型別名（型関数）を使うと良い)(748)
        - 型関数については (781) を参照.
      - `.`, `->`, `::` などを使いたいときは、その直後に `template` を付与すると良い(付与することで初めてその`メンバがテンプレートとして`仮定される)
      - 非局所名に依存する部分を極端に排除しようとする必要はない. (751)
      - 複数の具現化位置で生成したテンプレートの特殊化の定義が異なるとエラーとなる(752)
      - `従属関数`は、関数が呼び出された時、その宣言がスコープになくても、その関数はどれか一つの引数と同一の名前空間で宣言されているかのように扱われる. (753)
        - 従属名は、テンプレート定義箇所のスコープ内に存在する名前はもちろん、`従属する関数呼び出しにおける、１個の引数の名前空間に存在する名前`も探索する
      - `実引数依存探索（ADL）`が思わぬ挙動を起こす場合がある. 例えばユーザ定義の `copy` 関数を定義の引数に `std` ライブラリの型を指定した時に、`copy` はその引数の名前空間を探索するため、`std::copy` として解決する可能性がある. もし、ユーザ定義 `copy` と `std::copy` の仮引数が全く同じ場合は、`std::copy` が優先して呼び出される. これを回避するには完全修飾名で定義する. (`User::copy` など)
      - `基底クラス内へのアクセス`: 宣言時に規定クラスのメンバにある名前で、広域にも存在する同じ名前の`非従属名`を利用すると、それにバインドしてしまう(規定クラスのメンバを利用できない). これを解決する方法としては３つある(757):
        1. 従属型によって名前を修飾する(`T::g` など)
        2. 名前がそのクラスのオブジェクトであることを明示する(`this->g` など)
        3. using 宣言によって名前を同じスコープに導入する(`using T::g` など)
      - `クラス階層を全てテンプレート化した時`には、基底テンプレートクラスのメンバへのアクセスには `this->` は必須(758)
  - `テンプレートと階層`:
    - テンプレート T から T2 へ変換する場合、暗黙的に変換できる場合のみ生となるように実装する. これには、返却型に T を用いて実際に返却する値には T2 を用いたオブジェクトを用いる. (765)
    - コンパイラは仮想関数が使用されているかどうか知ることができないため、全ての仮想関数と、そこから呼び出す関数のコードは全て生成して置かなければならない. そのため、数多くの仮想メンバ関数を持つ巨大なクラス階層をパラメータ化することは、悪いアイディアとなるのが普通である. (766)
      - このため過度のパラメータ化は良いアイディアではなく、特に実装の詳細であり一部のメンバしか必要としていない型をパラメータにするべきでない.
      - パラメータにするのはクラス階層全体に影響する型である.
- `メタプログラミング`:
  - C++ 標準の定義には、次のような記述がある: '処理系には、呼び出し可能な小規模オブジェクトに対しては、動的にメモリを確保しないことを推奨する. 例えば f のターゲットが、１個のオブジェクトと１個のメンバ関数を指すポインタもしくは参照のみを保持する場合だ' (783)
    - これを実現するためには、`std::conditional` を利用する(783) conditional のような`型関数`は `型性質の述語`、`型の複合述語`などと呼ばれる. (784)
      - `型別名`: 型関数には `::type` が付くため、型別名を使って隠蔽すると良い:
        - `template<bool C, typename T, typename F> using Conditional = typename std::conditional<C, T, F>::type;`
  - `コンパイル時に繰り返し処理を実現したい時は再帰を用いる`.
  - メタプログラミングの再帰処理は、呼び出しが特殊化まで到達した時にその再帰が終了する(793)
  - 関数テンプレートの代わりにクラスを用いる場合は、返却値は `::value`, 返却値型は `::type` で取得(794)
  - `Enable_if`: 第一引数の条件が true であれば、第二引数の型を返却値型とする関数を生成し、false の場合は、その関数宣言自体を破棄
    - エラーの検知と通知を、実装から宣言へ移動する
    - `Enable_if` はコンセプトの一種ともみなせる: テンプレートに対する要件をより正確に仕様化しているためである
    - `Enable_if` は引数を受け取らないテンプレートにも、返却型を持たないテンプレートにも使用出来る.
    - `Enable_if` は、クラス宣言、変数、非テンプレート関数などには利用できない. テンプレートにのみ利用できる
    - `Enable_if` の実装詳細は(799)を確認. 第二引数はオプショナルで、型が必要でなければ実引数は未指定でも良い. この場合 void が得られる.
    - 最適化されたバージョンと、されていないバージョンを両方宣言するのは見苦しいので、非最適化バージョンでは次のような方法をとると良い:
      - `template<typename T> auto operator !=(const T& a, const T& b) -> decltype(!(a == b)) { return !(a==b); }`
      - 最適化された `!=` が存在する場合には、`decltype(false)` で置換失敗となり、`定義が具現化されない`ことが保証される(802)
  - `可変個引数（variadic parameters）`: `Args...`: 省略記号 `...` を使用したパラメータを `パラメータパック（parameter pack）`と言う.
    - `...` はなんならかのものが 0 回以上繰り返すと言う意味 (812)
    - 省略記号は、引数だけに限られていない. 例えば、複数の基底クラスを継承することを表現する `template<typename... Bases> class X: public Bases... { // }` のような使い方もできる(813)
    - `sizeof...(Args) 式`: `typename... Args` で指定された可変個引数の要素数を調べる.:
      - `template<typename T, typename U, typename = Enable_if<sizeof...(Types)==2>> tuple(const pair<T,U>&);`
      - 要素数が２の場合のみ pair から tuple をつくる tuple メソッドを宣言する
  - `ユニバーサル参照と完全転送`:
    - 関数テンプレートの引数に現れる `&&`. 実引数によって`右辺値参照`にも`左辺値参照`にもなりえる. つまり、左辺値にも右辺値にも対応した関数になる.
    - `右辺値参照は左辺値`という性質があるため `std::forward` を介さずにそのまま `std::invoke` に渡したら常に左辺値参照として受け取られてしまう. `std::forward` は右辺値参照の場合は右辺値に、左辺値参照の場合は左辺値にキャストしなおす機能で、 duration 関数が受け取ったときの左辺値、右辺値の区別を伝播させるために `std::forward` を使う.
    - 右辺値参照型の変数は式の左辺における（代入できる）から左辺値（右辺値には代入できない. `1=2;`などとできない）
    - `右辺値参照`: 呼び出し側が右辺値（≒ 一時変数）ならムーブしてよいことが自明なので自動的にムーブが呼ばれるという便利な仕組み.
    - `std::forward` を適用する引数が参照でなければ、`&&` でキャストするので常に右辺値参照になる.
      - `TR`: Reference to a type T, and `R`: Reference type.
      - `T& &` -> `T&` // lvalue reference to cv TR -> lvalue reference to T
      - `T& &&` -> `T&` // rvalue reference to cv TR -> TR (lvalue reference to T)
      - `T&& &` -> `T&` // lvalue reference to cv TR -> lvalue reference to T
      - `T&& &&` -> `T&&` // rvalue reference to cv TR -> TR (rvalue reference to T)
    - Refs:
      - [1](https://stackoverflow.com/questions/8526598/how-does-stdforward-work)
      - [2](https://stackoverflow.com/questions/3582001/what-are-the-main-purposes-of-using-stdforward-and-which-problems-it-solves/3582313#3582313)
      - [3](https://teratail.com/questions/282954)
      - [4](https://cpprefjp.github.io/reference/utility/forward.html)
      - (204) も参照.
- `STL ライブラリ`:
  - エラーコード(`errc`, `ec`):
    - 例外(exception) を利用できない場合は、`<system_error>` を検討する: エラーコードを分類、システム固有のエラーを可搬性の高いエラーコードへマッピング、エラーコードを例外へとマッピングする機能を提供(873)
    - `ec==ec2`: エラーコードの等価性を評価. 等価になるためには `category()`, `value()` が同じになる必要がある. それぞれかの型が異なる場合は、 `category().equivalent()` が定義する. (874)
  - `error_code` から `error_condition` を取得するには、`default_error_condition()` を利用 (877)
  - `error_condition` は潜在的に可搬性を持つエラーコードであり、システム固有の `error_code` とほぼ同一.(877)
    - error_condition には `<<` operator と default_error_condition() がない.
    - 複数のプラットフォームで動作するプログラムの開発者の便宜を図るため、可搬性を持つ値へとマッピングする、と言う考えに基づく.
  - `STL コンテナ`:
    - `コンテナ種別`:
      - `シーケンスコンテナ(sequence container)`: 半開放区間の要素シーケンスのアクセスを提供:
        - `deque`: `デック(deck)` とよび、vector と list が混ざったもの.
      - `連想コンテナ(associative container)`: キーに基づいた連想探索を提供
        - map, unordered_multimap など
      - `コンテナアダプタ(container adapter)`: ベースとなるコンテナへ特殊化されたアクセス手段を提供
        - stack, queue, priority_queue など
      - `コンテナ相当(almost container)`: 全てではないものの、コンテナの機能を多く持っている、要素のシーケンス - `T[N]`, array, string, basic_string など
        - STL コンテナ（シーケンスコンテナ、連想コンテナ）のみハンドルである.(886) array などはハンドルを持たないため、空き領域に対する処理を一切行わない(890)
    - `アロケータ(allocator)`: 要素のためのメモリを `operator new()` によって確保し、`operator delete()` によって解放する機構
      - コンテナのハンドルがアロケーたを保持する(888)
    - オブジェクトをコピーすることが妥当でない場合は、コンテナには、オブジェクトそのものではなく、オブジェクトを指すポインタを格納すれば良い 
      - 例えば、多相型では、 `vector<Shape>` ではなく、 `vector<unique_ptr<Shape>>` や `vector<Shape*>` を用いれば、多相的な動作が維持される. (891)
    - 比較演算: 順序づけの基準では、 `厳密で弱い順序(strict weak ordering)` を定義する必要がある.
      - 基準:
        - 非反射性(`cmp(x, x)` は false),
        - 対称性(`cmp(x, y)` なら `!cmp(y, x)`)
        - 推移性(`cmp(x, y)`, `cmp(y, z)` なら `cmp(x, z)`)
        - 等価性の推移性(等価性判定 `equiv(x, y)` を `!(cmp(x, y)||cmp(y, x))` とした時、`equiv(x, y)`, `equiv(y, z)` なら `equiv(x, z)`. `!(cmp(x, y)||cmp(y, x))` は、非反射性を持つならば一つ目 -> 二つ目の判定で、連続して false となるため、結果として等価性を判定することができる)(891)
          - つまり、独自比較処理 では等価性判定処理(等値演算)を提供しなくて良い.
      - C 言語スタイルの文字列比較では、std::less ではなく、独自比較処理用のファンクターを `strcmp(p,q)<0`を使って実装する(892)
      - 等値演算(デフォルトでは == )が透過性判定と常に同じ結果となる場合は、`全順序（total order）`であると言う.
    - `reserve` が性能に貢献することはほとんどない. 性能を予測しやすくするとともに、プログラムにとって不便な、反復氏が無効になる自体を防ぐためのものだと考える(899)
    - `v.begin()`, `b.end()` の duplicate 判定では、`if(p!=v.begin() && *(p-1)==*p)` を使うと良い.
    - set に組み込み型以外のキーを与える場合、比較関数を与える必要がある. (914)
    - `unordered_map`: 挿入した順序で要素が出力される保証はない.(915)
      - 大量のデータから高速な探索が必要であるときに使用.(926)
      - または、要素の型が自然な順序を持たない場合（`<` 演算で理にかなった比較を行えない場合）も非順序コンテナを選択する
      - hash 関数は string などの一般的な型に対しては、標準の hash の特殊化が提供されているためユーザが提供する必要はない(bool,
        type_index, thread::id, error_code など).(916)
        - hash 関数を定義する簡単な方法は、hash を特殊化することである(918)
          - 2 つのハッシュ値の排他的論理和を計算すると size_t 型に収まる値を計算することができる.(918)
      - コンストラクタに与える `n` は`ハッシュ表`の大きさであり、`バケット数`と言う(unordered コンテナの要素数とは違う)
      - 複数のキーが同じハッシュ値を持つことを、`同じバケットがある`と言う(920)
      - `load_factor()`: バケット数で割った要素数を返す. `double(c.size()/c.bucket_count())`
        - `占有率(load factor)`は容量に対する利用率のこと. 例えば、バケット数が 100 要素で size が 30 の時占有率は 0.3 となる
        - 1,000,000 要素を利用したい時に、max_load_factor を 0.7 にセットするときには 1,430,000 要素確保 (reserve) する (920)
    - `コンテナアダプタ`: stack などの標準のコンテナをラップして作成されてたもの
      - pop をするときは先に top を実行して、不要かどうかの判定を行うことで、アンダーフローしないことを保証すること.(923)
  - `STL アルゴリズム`:
    - 反復子が指すデータ構造について、アルゴリズムは何も知らない. そもそもアルゴリズムと処理対象のデータ構造を分離するためののもである(929)
    - アルゴリズムで、述語か値かを受け取りうる関数を明確に区別できるように、述語を受け取る関数には `_if` をつけるようにする(930)
      - 述語（渡されたポリシー引数）の中で勝手に要素を変更しようとすると処理が不明瞭になるため避ける(931)
        - そのために const 参照を受け取るようにする.
    - `search`: 部分文字列の探索を行うときに便利なアルゴリズム. 単一の要素を探索する場合は、find() binary_search() を利用(935)
    - `copy`の出力先に対してオーバフローいないことを保証するために、インサータを使う(937)
      - `copy(vs.begin(), bs.end(), back_inserter(v))`
      - unique + erase で eliminate_duplicate を作成できる. `c.erase(unique(c.begin(), c.end()), c.end());` (938)
    - remove は unique と同様に実際の入力値の大きさを変更しない. (939)
    - list は標準でランダムアクセス反復子を定義していないため、list のソートには専用の処理が必要.(944)
      - なお一度 vector にコピーして、その vector をソートして、そのあとで要素を list へ再度コピーする方法がある(944)
    - partial_sort_copy のコピー先はランダムソート反復子でないといけないため、直接 cout を指定することはできない(944)
    - find のような逐次探索は大規模シーケンスには効率が悪いため、ソート済みのシーケンスにある値が存在するかどうかは２分探索がよい(946)
      - ソート済みのシーケンスの並びを維持したい場合は、lower_bound or upper_bound で位置を特定し、pair second の前後に insert すると良い(947)
    - `集合アルゴリズム`: 入力シーケンスは、ソートされていることが前提で、出力シーケンスもソートされたものとなる
      - includes, set_union, set_symmetric_difference など
  - `STL 反復子`:
    - `シーケンス(sequence)`は、２個の反復子によって指定される半開放区間 `[begin:end)` として定義される(954)
    - `[p:p)`: 空シーケンス
    - シーケンスの探索が最後に達したかどうかの判定は `b<e` ではなく `b!=e`で表す. これは < をサポートしているのがランダムアクセス反復子に限られるためである
    - 一般に次のようなことは行えない: `template<typename Iter> typename Iter::value_type read(Iter p, int n) {...}`
      - こうではなく次のような記述になる: `template<typename Iter> typename iterator_trails<Iter>::value_type read(Iter p, int n) {...}`
    - 反復子の処理: p がランダムアクセス反復子でなければ、アルゴリズムには n ステップが必要(959)
    - `<iterator>` を `#include` していると、begin(), end() のメンバを持つユーザ定義のコンテナは自動的に非メンバ版を持つことになる.
      - 独自に実装したコンテナに対して、それらの非メンバ関数を持たせたいときは、追加で提供する必要がある. (965)
    - `function`: `bind()` の結果をある特定の型の変数に代入するのであれば `function` を使う(969)
      - 呼び出し可能オブジェクトを単純に呼び出すのではなく function 型を検証するために用意されている(970)
      - `function<int(double)> f; f=[](double d){ return round(d); };` のように変数に関数型を与える.
      - `bool b = f;`: 関数 f を bool へ変換する. f が空でなければ true(`nullptr` or `function<T> f {};`)
      - `p=f.target<F>()`: `f.target_type()==typeid(F)`の場合、p は保持しているオブジェクトを返す.
      - `ti=f.target_type()`: 呼び出す関数を持っていれば、その関数の型を表す `type_info` オブジェクトを返す
    - array を組み込みの配列より優先する理由(976):
      - 想定外のポインタへの変換を避けるため
        - 関数へ渡すときの変換
        - 多相体のポインタへの型変換によってオフセットがズレることによる災難
      - array は自身の要素数を知っているため、標準ライブラリのアルゴリズムで利用が用意
      - array は全要素の型が同一の tuple とみなすことができる(977)
        - `tuple_size<array<T,N>>::value; // N`, `tuple_element<S,array<T,N>>::type; // T`
        - `get<i>` を用いた i 番目のアクセスも可能.
    - `bitset`: ビットに対して、番号ではなく名前を与えたいのであれば、`set`, `列挙体`, `ビットフィールド`を使った方が良い.(977)
      - bitset は要素数が固定であると言う点で `vector<bool>` と異なる.
      - またビットを操作する処理を持つ点でも異なる
      - 組み込みのポインタを用いて、単一ビットを直接アドレッシングすることは不可能なので、bitset はビットへの参照型（プロクシ型）を提供する. これは組み込みのポインタが何らかの理由で不適切となるオブジェクトをアドレッシングするための、有用なテクニックである(978)
      - constructor: `bitset<N> bs{s,i,n,z,o}`:
        - N: 要素数. n: 実際に利用する要素数. n が指定されていないときは、`npos` で`末尾を超えた位置`である、`末尾までの全ての文字列を意味する処理`が適用される
        - i: 開始位置(index)
        - s 内の `[i,i+n)` の n ビット. s は `basic_string<C, Tr, A>`
        - z: zero に利用する型を C とする文字 `C{'0'}`
        - o: one に利用する型を C とする文字 `C{'1'}`
        - "n0g00d" のような '0' or '1' 以外の値を渡すとエラー
      - bitset helpers:
        - `&=`, `|=`, `^=`, `<<`, `>>` のようなビット単位演算ができる `~` 補集合で、`bs2=bs; bs2.flip();` の省略版(980)
    - `vector<bool>`:
      - `vector<T>` と同様添字の値が大きい方がアドレスも高位となる
        - このレイアウトは bitset とは正反対(978)(982)
- `メモリと資源`:
  - `shared_ptr`:
    - 参照カウンタでのデータの競合を防ぐ必要があるため unique_ptr よりもコストが大きくなる可能性がある.
    - 単一の最後のノードが大規模のデータを保持する場合、ノード破棄による`デストラクタの連鎖`によって、著しいガベージコレクションの遅延が発生する可能性がある(例えば、ノード A が大量の他の shared_ptr を持っていたとして、それらの大量の shared_ptr はノード A にしか所有者がいない場合、ノード A が解体されることで大量のデストラクタが呼び出されることになる).
    - `sp.reset()`: `shared_ptr{}.swap(sp);` すなわち、sp は pointer{} を保持し、一時オブジェクトの shared_ptr{} の破棄によって、それまでのオブジェクトの参照カウンタをデクリメントする
  - `weak_ptr`:
    - 目的のオブジェクトにアクセスする際に、weak_ptr が、shared_ptr に変換されることになるため比較的少数の処理だけ提供されている(995)
    - 利用例: 小惑星ゲーム
      - 全ての小惑星は他の小惑星と衝突を回避するために他の小惑星のリストを保持する必要がある.
      - 小惑星同士が衝突すると一つ以上の小惑星が崩壊する（デストラクタによって解体される）
      - 一方で他の小惑星が(衝突の影響の計算などのために)探索中であれば、小惑星を解体してはならない.
      - そこで必要となるのが、まだ崩壊していない可能性を持つ小惑星リストと当面の間維持する方法である -> 他の小惑星が `wp.lock()` を実行中の間は、shared_ptr の解体を先送りする. どの所有者も lock せず、参照カウントも 0 になった時に初めて破棄する. lock 解除後も他の小惑星が参照しているときは、破棄されず最後の小惑星がなくなるまで解体されない.
  - `アロケータ（allocator）`:
    - 必要な時にメモリを獲得し、不要になった時点で返却する役割.(996)
    - 標準の全てのコンテナは(new によってメモリを確保し、delete によって解放する)デフォルトのアロケータを持っている(997)
    - `内側のコンテナと外側のコンテナ`が別々のアロケータを使う場合は `scoped_allocator_adaptor` を使う.(1001)
      - scoped_allocator_adaptor でラップするだけで良い. `using Xstring = basic_string<char, char_traits<char>, My_aclloc<char>>;`の時：
        - 通常 vector は `vector<string>` とする
        - scoped_allocator_adaptor の場合 vector は `vector<Xstring, scoped_allocator_adaptor<My_alloc<Xstring>>>` のように第二引数に scoped_allocator_adaptor でラップしたアロケータを追加する(1001)
  - `ガベージコレクションインタフェース`:
    - `利用しない場合`:
      - 資源ハンドルが利用できる場合. 標準ライブラリの string, vector, unordered_map, thread, lock_guard など.
      - unique_ptr を利用すべき場合.
        - 自分が利用する資源を暗黙裏に管理しないオブジェクト (pointer)
        - 想定よりも先に破棄されることを防ぎたいオブジェクト (適切なデストラクタを持たないため)
        - 特殊な方法で確保する必要があるオブジェクト (デリータ)
      - shared_ptr を利用すべき場合.
    - メモリ以外の資源は扱えないが、メモリの回収、再利用は行える.
    - メモリ以外の資源を処理しようとして、一般的なファイナライザを使おうとしてはいけない(1003)
    - `安全に派生したポインタ（safely-derived pointer）`: new から作成したポインタと、その部分オブジェクトを指すポインタ
    - `偽装ポインタ(disguised pointer)`: 安全に派生したポインタではないポインタ
- `ユーティリティ`:
  - クロック型: `system_clock`, `steady_clock`, `high_resolution_clock` (1015)
  - `型関数`:
    - `一次型述語（primary type predicate）`: 型の基本的な性質を調べる.(`is_void<X>`, `is_integral<X>`, `is_lvalue_reference<X>`, `is_rvalue_reference<X>`, `is_member_object_pointer<X>`, `is_member_function_pointer<X>`)(1019)
    - `複合型述語（composite type predicate）`
      - `is_reference`: `is_lvalue_reference<X>` or `is_rvalue_reference<X>`
      - `is_member_pointer`: `is_member_object_pointer<X>` or `is_member_function_pointer<X>`
      - `is_scalar`: 非クラス、非関数か? `is_fundamental`: 基本型(int, float, bool, char など(146))か?
      - `is_object`: 非関数か?
    - `型性質述語（type property predicate）`: 型の基本的な性質を調べる
      - `is_const`: const か?
      - `is_destructible`: 解体可能か?(`~X()` が削除されていないか)
      - `is_empty()`: 非 static data member, 仮想関数、仮想基底、`!is_empty<Base>::value` が成立する基底クラスを一切持たない場合
- `文字列`:
  - 速度性能向上を意図した最適化が必要な場合は `at()` ではなく、`反復子`や `[]` を利用(1049)
  - [Ref](https://cpprefjp.github.io/reference/string/char_traits.html)
  - 文字の判定には、標準の`文字クラスの判定関数`を利用する:
    - 他の locale に変更が容易である: `islower(ch, danish) // danish をロケールと仮定した時に、ch はデンマーク語における小文字か?`
  - 標準では４種類（char, char16_t, char32_t, wchar_t）の char_traits の特殊化を提供する(1035)
  - `std::string` と同じ型を作るには、上記の４種類のうち char の特殊化`std::char_traits<char>`を利用して、basic_string に与える:
    - `std::basic_string<char, std::char_traits<char>>` == `std::string`
    - 比較では、char_traits で定義されている compare が利用される(`char_traits::compare()`)
  - オリジナルの型を作成する場合（b B の比較を insensitive にしたいなど）は、`std::char_traits<T>` をベースとした `base_traits` を使って、そのメソッドを流用するとよい.
  - 0 を渡すと nullptr になるため注意 `string s{0} // s == nulltpr`
  - C 言語スタイルのポインタを渡してはいけないし、動作するかどうかはそのポインタの値に依存 `const char* p = 0; string s{p}; // DON'T`. またその値を c_str で変換した結果を `strcmp()` などの C 言語の文字列関数に対して実行しない
  - string を処理系が処理できないほどの長さで初期化しようとすると `std::length_error` 例外が送出される
    - この長さは `s.max_size()` で確認. resize や reserve がこの数値を超えると例外を送出.
  - string コンストラクタの pos は `[b, e)` ではなく、`(pos, n)` (n は文字列の length で反復子で表すならば `[b, e]`) である点に注意.
  - C 言語スタイルの `char*` への暗黙的な変換はエラーにつながりやすいため存在しない. 変換には明示的に `c_str() またはそれをラップする data()` を利用(1041)
  - 文字列から数値への変換には `sto*`関数を利用. ただ `sto*` を直接利用するよりも `string_stream` や（`to<X>`などの）汎用値抽出関数を優先した方がよい.(1049)
    - 基数用の引数には`[2:36]`の範囲を受け取れる.
    - 例: `string s = "149F; stoi(s) // 149, stoi(s, nulltpr, 10) // 10 進数で処理 -> 149, stoi(s, nulltpr, 8) // 8 進数で処理 -> 014`
    - 変換可能な文字列がなければ `invalid_argument` エラー
    - 目的の型に変換できない場合（stoi としているのに int 以上の数値を検出した場合など）`out_of_range` エラー (かつ `errno=ERANGE` をセット).
  - `assignment 類`:
    - `s.assign(new_s); // new_s は string or initializer_list<char_type>`
    - `s.append(n,c); // 文字 c を n 個追加`. insert, erase なども利用できる(1045)
  - `部分文字列`:
    - replace である`部分文字列`の置換ができるが、マジック定数を利用することが多いためエラーにつながりやすい(1046)
    - `部分文字列` の探索は find or rfind
  - string を関数から返却するときは RVO (Return Value Optimization)を利用する. `std::string func() { std::string rv{"I'm a local variable."}; return rv; }`:
    - Using `std::move()` can be worse than simply naming the variable to be returned because it suppresses the `return value optimization`.(You should not return a reference to a local variable. It is always undefined behavior, plain and simple.)The return value optimization allows for an object to be returned to the caller without needing to copy that object.
    - `RVO as compiler optimization` versus `copy/move-construction` as in C++ language rules, which are two very different situations of `eliding a copy`.
    - [Ref](https://stackoverflow.com/questions/12011426/how-to-use-move-semantics-with-stdstring-during-function-return)
- `正規表現`:
  - `関数`:
    - `regex_search`: 文字シーケンスを探索（ファイルのようなシーケンスの一部からパターンを探索. 全ての文字シーケンスに対してパターンを比較する場合は regex_match を利用）
      - e.g. 綴りの間違いの検出(1065)
    - `regex_match`: 固定長の文字シーケンスと比較 (テキスト一行など期待している形式とマッチするかどうかに使用)
      - e.g. 各行の形式が決めらているテーブルの集計(1064)
    - `regex_replace`: パターンを置換
  - `反復子`:
    - `regex_iterator`: 文字シーケンスに含まれるパターンを探索しながら反復処理が可能.
      - `regex_iterator{}` は末尾を表すため、反復処理の終了条件は `p!=regex_iterator{}` とする(1068)
  - `()` group (部分パターン)化した文字列は matches コンテナから取得できる
    - 部分パターンではない `()` を定義したい場合(or をグループ化したい場合など`(a|b|c)`.)は `(?:` から始める(1056)
    - 入れ子の部分パターンは認識されない
    - `\1` などですでにマッチしたグループを参照した時には、参照する側もグループとしてみなされる
  - 部分一致は複数の `sub_match` を持つコンテナである `match_results` に格納されている(1059)
    - `match_results[n]`: n 番目にマッチした sub_match にアクセス
  - C++ はデフォルトで最長一致(`Max Munch 規則`)ある. `lazy` or `non-greedy` にしたいなら繰り返し表現の直後に `?` をつける(1053)
  - `regex_replace` と書式か指定子（`$1`, `$&` など） でマッチした内容を書式化できる.(1062)
- `入出力ストリーム`:
  - ストリームのモード(1077): app(ファイルの終端に追加), ate(ファイルオープン後にファイル終端に移動), binary, in(既存のファイルをオーバライド), out, trunc(ファイルをゼロに切り詰める) これらのモードは ios_base が提供(1089)
  - `basic_istream` は `istream`, `istringstream` などの入力処理の詳細を定義するクラスの基底クラスになることを意図したもの(1081)
  - `sentry クラス`が istream の実装の詳細である. このクラスは標準ライブラリやユーザ定義の入力処理に共通するコードを提供する(1082)
  - `sstream`: string への入出力を行うストリーム. istringstream, ostringstream, stringstrea.
    - 初期化後は `good() | eof()` で正常を意味する 1 を表し、問題があれば 0(1079, 1080)
      - `fail()`は予期しない事態が発生したかどうか確認できる(`cin>int_val` に `'x'` を検出した場合など)(1080)
      - これらの関数は ios_base のストリームの状態を表すメンバ iostate の定数値を読みとる関数である. (これらの関数も ios_base が提供)(1089)
    - `stringstream(basic_stringstream<C, Tr, A>)`のデフォルトコンストラクタ `stringstream ss{} == stringstream ss{ios_base::out|ios_base::in}` (1078)
    - `ss.rdbuf()`: ss の`文字列ストリームバッファ`を指す(`basic_stringbuf<C,Tr,A>`)
    - `ss.str() == ss.rdbuf()->str()`: ss の文字列（string）のコピー
      - `ss.str(s)`: ss のストリングバッファを s で初期化
  - `操作子`:
    - `cout<<pf`(== pf(cout)) のように関数へのポインタを << の第二引数に与えるとその関数が実行される
    - `cout << estprecision(4) << angle;`: 浮動小数点数の変数 angle の値を 4 桁で出力(1087)
    - ostream がフラッシュされるのは、解体された時、`tie()`によって結びつけられた istsream が入力待ちになった時、処理系が必要性を判断した時である(1096)
  - `バッファリング`(1100):
    - 出力ストリームは文字をバッファに置く. しばらくしてから、文字は本来の出力先へと書き込まれる（フラッシュされる）
    - バッファがいっぱいになり本来の出力先にフラッシュせざるをえなくなるまで、文字を配列ないに保持する
    - このようなバッファは `streambuf` と呼ばれる
      - basic_streambuf は基底クラスとして利用されるように設計されているため全てのコンストラクタは protected (1101)
- `ロケール`:
  - `facet(特性項目)`:標準ライブラリが直接サポートしないロケール固有の実態を表現するための新しい facet を locale に追加することができる. (1111)
    - 季節名の出力形式を決定するような facet の定義も可能(1121)
    - facet の locale 内部に保持されているポインタを介して管理することを想定している
    - facet のコンストラクタの引数に 0 を与えることは、facet がどこからも利用されなくなった時点で locale が acet を破棄すべきことを意味する(1121)
    - locale が facet を特定するために各 facet インタフェースは個別の id を持つ必要がある. id はクラスではなく、インタフェースや動作を識別するものなので、異なる facet が全く同じインタフェースと（locale に関する）セマティクスを持つのであれば、同じ id を持たせるべきである. (1122)
      - ただ Season_io のインタフェースの実装をした US_Season_io に対しては専用の id を与える必要はない(has_facet などのおうな、locale に対する処理は、同じ概念を実装する facet が同じ id で識別されることを想定しているため)(1125)
    - プログラマが必要なデータは facet の派生クラスの中で定義する必要があるが、facet は変更不可能であることを想定しているため、全てのメンバ関数は const とすべきである(1122)
  - locale は複数の facet を保持するコンテナと見なすことができる(1114)
  - プログラムテキストに locale 名前文字列を直接記述しないようにする(1159)
  - locale はストリーム入出力の際に、暗黙裏に利用されることが圧倒的に多く、デフォルトはストリーム作成時における広域 locale である.
  - 広域 locale の変更が既存（作成済み）の入出力ストリームに影響を及ぼすことはなく、広域の locale 変更前に設定された locale が利用され続ける(1116)
  - Microsoft 社は言語、国名、省略可能なコードページ番号という形式を使用:
    - コードページ(code page)番号とは、名前付きの（あるいは番号が振られた）文字エンコーディングのこと(1117)
  - locale 文字列は、プログラムの実行環境から取り出せるようにする（例えば、`locale("")` を利用したり、ファイルを読み取ったりする）
    - またはユーザから直接入力させる方法もある(`cin>>lo; locale::global(locale{lo})`)(1118)
  - 標準 facet:
    - C は文字型でなくてはならず、char, wchar_t に対して動作が保証されているが、それ以外の文字列 X を標準入出力で使う必要がある場合は、処理系固有の facet 用の特殊化に頼るか、X に対する適切なバージョンの facet の自作が必要. 例えば、X と char 間の変換の制御には`codecvt<X, char, mbstate_t>`が必要となる(1126)
    - `特性`:
      - `collate`: 文字の配列の比較方法を提供
        - constructor に渡す引数は facet を破棄する責任が locale にあるのか、それともユーザにあるのかを表すのもで、デフォルトは 0 で　 locale に管理させることを意味する
        - transformt は他の transform が返却した結果との比較を通常の文字列として行えるような文字列を生成する(1129)
        - compare は C 言語スタイルの文字列ではないため(`[b:e)` の範囲で比較)、文字列の最後に 0 が入っている場合それは終端文字ではなく文字列の一部として扱われるので注意. (1130)
          - 直接 compare を呼び出さなくても、locale の () 演算子を利用すると述語(sort の引数としても利用可)として呼び出すとができる: `void f(string &s1, string &s2) { locale{}(s1, s2); // instead of, ({use_face<collate<char>>(locale{})).comppare(s1, s2); `(1120, 1130)
          - 例えば, german の ä は一般的な文字セットでは c よりも大きいが、a の一種として扱われるため c よりも前にくる必要がある. (1130)
        - `*_byname`: collate_byname はプログラムの実行環境で名前が与えられた locale から collate を抽出できる.
          facet をプログラムテキストとしておいた上で、 データを `_bynamefacet` 特性に入れるという方法がある(1131)
      - `numeric`:
        - `num_put` `num_get` が入出力を制御し、これらは `numpunct(numerical punctuation)` facet によって定義される書式を利用する.(1131)
      - `moneypunct`:
        - `money_put` `money_get` が入出力を制御し、これらは `money_base` 特性が定義する書式を利用する(1137)
        - ユーザ定義 money 型を２使う方法：
          1. Money を表すオブジェクトを使用し、入力値をそのオブジェクトに渡して適切な型にキャストする方法. この方法だと読み取った値は、オブジェクトの内部に保持しなくていけなく、利用する前に必ずキャストしないといけない. また、locale に依存しない方法で金額を読み取ろうとした際に発生したにゅうりょおくエラーの検出もできない(1137)
          2. 上記のようなデメリットを改善するには、入手強く処理で Money への変換(キャスト)する方法を利用する(`moneypunct` を拡張)(1137)
        - `moneypunct`:
          - International は、moneypunct を拡張するときに第二 template 引数に渡す(1138)
          - International が true だと intl メンバも true となり、`国際`表記の通貨記号を利用する. この国際表記は４文字の C 言語スタイルの文字列のことで、例えば　 USD, DKK, EUR などである(1139)
            - これらは C 言語スタイルなので末尾は null 文字('\0')である.
          - International が false だと `$` `€` `￥` などの記号を用いる. これは`ローカルな`表記の通貨表記である
          - sign, value, symbol は正確に一回だけ出現する必要がある.
            - space は一個以上の空白を表す
            - none はパターンの末尾である場合を除くと、0 個以上の空白文字を表す
        - 日付と時刻の初期化:
          - `time_get` 特性項目の基本的な考え方は、`strftime()` を同じ書式を用いて `put_time()` が出力するものを、`get_time()` が読み取れるようにすることである. (1143)
        - 文字クラス:
          - locale の文字クラスを表現する ctype 特性項目を利用(1144)
          - 大規模文字セットと小規模文字セット間の変換の等価性については保証はない(1147)
            - これは、大規模文字セットへの変換を容易にするために、複数の変換された表記用の複数のサブセットを持っているし、小規模文字セットないの文字は、変換表記を簡単にするために、複製されることがあるためである
            - 基本ソース文字セットについてはこれが保証されている. `widen(narrow('x',0)) == 'x'`(145, 1147)
          - `codecvt`: 文字コードの変換を行うため、ストリームバッファと外部記憶との間で、文字を移動する際の文字セット変換機能も提供する(1148)
      - `メッセージ`:
        - プログラムとのやりとりを母国語で行たい場合にそれらのメッセージをライブラリを通して保存しておくような仕組み(読み取り専用の小規模なデータベース、レポジトリ)(1152)
        - `catalog open(...)` でカタログを利用する前に読み取っておく必要がある.
        - `get(cat, set, id, "def")` は `(set, id)` で識別されるメッセージをカタログ cat から探索し、見つかった場合はその文字列を返却し、見つからなかった場合は指定したデフォルトの文字列(`string("def")`)を返す.
        - messages の全てのメンバ関数は const なため、カタログのデータ構造(`vector<Set>`)は facet の外部に保持する必要がある(1153)
        - catalog は一ファイルとして保持しておいて、その中に複数のセット(set) 区切りでメッセージを保存する.
          - set ごとの区切りは特に指定はなく `<<<`msg1\nmsg2\n`>>>` のような形で保存し、これを `do_open` が読み込むように実装する(1153)
        - messages はユーザとのやりとりだけではなく、他の facet 用の文字列の保持のためにも利用できる.(1154)
          - 例えば、Season_io などの `string Season_io::to_str(Season x) const` では、ユーザが locale に依存する文字列を入力した際にそれに対応するメッセージを辞書の中から探索し、マッチしたインデックス(int 型)を元に Season オブジェクトを作成するということができる.(存在しない場合は、false を返す)(1155)
      - `Covenience interface`:
        - `ctype`: ある文字が特定の文字クラスないに存在するかどうかの判定をする.
          - 一つの引数を受け取るバージョン(1033)は、現在の C 広域ロケールを利用するものであり、C 広域ロケール と C++ 広域ロケールが異なるという稀なケースの場合を除くと 2 個の引数バージョンに対して `locale()` を適用したものとみなすことができる.(1156)
          - `codecvt_utf8`というコード変換 facet を利用すると cout の locale を変更することなく、cout に対して `UTF-8` のマルチバイト文字列を直接出力できるようになる.(1157)
