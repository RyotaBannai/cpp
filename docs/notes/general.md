### General concepts

- `左辺値`（`lvalue`）：メモリ上の特定の場所に置かれ、他のオブジェクトが同じ内容を持っていてもアドレスによって識別することができるオブジェクト
- `右辺値`（`rvalue`）：右辺値とは違ってアイデンティティを持たない（＝いつでも安全に参照することができるアドレスを持たない）オブジェクト。=> 「低コストでムーブできる値である」と言われる（Rust はもとよりオブジェクトの代入は、所有権の移動によるムーブが発生する）(14)

- `実行時オーバーヘッド`を伴う実装は排除されている。例えば、全オブジェクト内に`管理機能（housekeeping information）`を埋め込んだ上での構築は排除されている。そのため、２個の 16 ビットフィールドを持つ構造をユーザが定義すると、１個の 32 ビットレジスタに収まる。`new`, `delete`, `typeid`, `dynamic_cast`, `throw 演算子`, `try ブロック`を除くと、C++の式と文に対して、実行時の支援が必要となることはない。(17)
- `波括弧 {} で変数を初期化`：暗黙裏の型変換を許容しない。C のような伝統的な`= 代入演算子`で値を C++ でそのまま代入すると、暗黙裏の型変換が行われる。そのため波括弧の使用が推奨される(49)
  - この手法は、`並びによる初期化(list initialization)と呼ばれる`. この初期化では、`縮小変換`を許さない例えば：(169)
    - 整数値は、その値を保持できない他の整数型へ変換されない。例えば、`char から int`
    - 浮動小数点数値はその値を保持できない他の浮動小数点型へ変換されない。例えば、`double から float`
    - `浮動小数点数値`は`整数型`へ変換されない/ `整数値`は`浮動小数点数値`へ変換されない
  - `auto` を使うときは = を使う方が良い。なぜなら例えば`auto z {99};` の型は `initializer_list<int>` になってしまう
    - そのため、`並びではないオブジェクト(container のようなオブジェクト)`の初期化は `=` を利用するのが良い(または併用 `={}`)
- `定数（const）`
  - `const` 修飾子をつける（関数の引数に渡した時に変更されないことを保証）
  - `constexpr` コンパイル時に評価されることを明示し（つまり関数の計算結果を変数に代入する際にその修飾子として使う）、読み取り専用のメモリ領域に配置することを許可するとともに変更不可にする（性能も向上）
    - `constexpr` で修飾された変数は`定数式`にする。そうでないとそれ自体が定数式にならない（例：`const double v = 2.1; constexpr double d = sum(v)`）(51)
- `組み込み型（built-in type）`: `基本型（bool, char など）`・`const 修飾子`・`宣言演算子（declarator operator）(&, *, [])`とで組み合わされる型
- `ユーザー定義型(user-defined type)`: C++ の抽象化機構（abstraction mechanism）(クラスや列挙型など)を使ってユーザーが定義できる型(55)
- `インターフェース`: Vector の`内部データ表現`である 2 つのメンバ `elem`, `sz` は `public メンバであるインターフェース`、すなわち `Vector()`, `operator[]()`, `size()` を介してのみアクセスできる(57)
  - C++ におけるインターフェースは Go や Rust などの impl するためのメソッドの型の集まり、とすることもできるし、
  - 内部データ表現を操作するためのメソッドの定義とすることもできる（Rust のコンテキストで言うとインターフェースに定義されている実際の具象 method）
- `クラスの普遍条件（class invariant）または単に 普遍条件（invariant）`: クラスを初期化するときに必要となる前提条件を表す文であり、これはコンストラクタが保証しなければならないが、その内容は実装者の責任である。例えば、適切に `std::length_error`, `std::bad_alloc` など検出したエラーを呼び出し側に通知する必要がある。呼び出し側はこれらを適切に補足する必要がある。(64)
- `静的アサーション`: エラーを型チェックなどと同様なコンパイルエラーとして検出するための機構である。例えば、`static_assert(4 <= sizeof(int), "integers are too small");`(65)
  - 静的アサーションは、ジェネリックプログラミングの引数型に対して使うことが効果的である
  - static_assert を使うときは、条件部分に使う変数は定数でないといけない
- `インライン化`: 効率を重視すると、単純な演算はインライン化することになる。すなわち`コンストラクタ`、`+=`、`imag()` などの`単純な演算`は、関数呼び出しの機械語が生成されないように実装しなければならない(69)
  　 - クラス内で定義する関数は、デフォルトでインライン化される。
- `資源獲得時初期化(RALL = Resource Acquisition Is Initialization)`: コンストラクタで資源（メモリ）の獲得を行い、デストラクタで必ず資源の解放をする技法（または、`データハンドルモデル（handle-to-data model）`の一つである）
  　- `裸の new 演算`や `裸の delete 演算`を内部に隠蔽する、かつスコープなどから抜けると必ず呼び出されるので資源（メモリ）リークやエラーを防ぎやすくなる(72)
- `コンテナ（Vector など）の初期化`: `std::initializer_list<T>` を使う(73)
- `抽象型(abstract type)`: データの定義ではなく、型を定義したクラス（インターフェースを分割したものとは別）
  - 具象クラス（concrete class）で実装を行うことを想定した関数定義を `仮想関数（virtual function）` と言い、`virtual 修飾子`をつける
  - 仮想関数には `=0` という記法をつけた`純粋仮想(pure virtual)関数`と言う種類の仮想関数があり、その関数は具象クラスで`必ず`実装しなければいけない
  - `具象型`は一般的に`多相型（polymorphic type）`として使われる
- メンバのデストラクタ（クラスのメンバとして持つオブジェクト自身のデストラクタ）は、クラスのデストラクタから暗黙裏に呼ばれる. また、具象型のデストラクタは抽象型のデストラクタを自分のクラス名でオーバーライドできる。
  - クラス階層（class hierarchy）の場合仮想関数の呼び出しの仕組みによって適切なデストラクタが呼ばれる。派生クラスのデストラクタは暗黙裏に基底クラスのデストラクタも呼び出す(78)
- `仮想関数テーブル（vtbl）`: 抽象クラスが実際の具象クラスの実装された関数を呼び出す仕組み（各具象クラスごとに作成して、関数の位置をインデックスを振ってマッピングしたテーブル）(76)
  - メモリのオーバーヘッドは、抽象クラスが保持する`具象クラスへのポインタ`と、`具象クラスの vtbl へのポインタ`
- `unique_ptr`: ユーザーが不要なポインタを delete しない可能性、または失敗する可能性がある。そのため、スコープから抜けるときに不要になったポインタを自動で削除するための機構が`unique_ptr`である(80)
- `資源ハンドル(resource handle)`: ポインタ経由でオブジェクトにアクセスしなければならないこと
  - 配列を使うとリークを起こしていないか木を配る必要があるので、基本的には内部に資源ハンドルを持つ（所有権を表すポインタ） `vector`, `string`, `unique_ptr`を使うこと(195)
  - 反対に資源ハンドルの外部に存在するポインタ（new を使って空き領域にメモリを確保して割り当てた配列など）は自分で `delete` する必要がある、とすると資源管理を単純化することができる(196)
- `クラスオブジェクトのコピー動作`: 以下の２つを検討すると良い.(通常のコピーでは、同じアドレスを参照していまい mutable なオブジェクトになってしまうため)(82)
  - `コピーコンストラクタ（copy constructor）`: `Vector(const Vector& a);`: 必要なメモリを確保し、与えられたオブジェクトと同じ内容をコピーする。そうすると元のオブジェクトとは別のメモリ常に新しいオブジェクトを作成することができる
  - `コピー代入（copy assignment）`: `Vector& operator=(const Vector& a);`: 同様に必要なメモリを確保し、内容をコピーする。その後に元のオブジェクトを削除する. コピーコンストラクタと違うのは、代入操作なので新しいオブジェクトを返却しないといけない点であり、これには　`*this` を使う.
- 階層内のクラスに対して、デフォルトのコピーやムーブを利用すると、ほとんどの場合は惨事につながる。と言うもの、基底を指すポインタだけ与えられても、派生クラスのメンバについては何もわからないからでさる。こう言う場合には、デフォルトのコピー演算、ムーブ演算を削除(delete)するのが良い。(`Shape& operator=(Shape&&) =delete`)
  - また、デストラクタを宣言しておけば、これらの delete を忘れても実害がない。と言うのも、ユーザーが明示的にデストラクタを宣言したクラスに対しては、デフォルトの`ムーブ演算`が暗黙裏には生成されないからである。さらに、この場合の`コピー演算`は非推奨になっている。このため、コンパイラが暗黙裏にデストラクタを作成するとはいえ、ユーザーが明示的にデストラクタを定義する理由の一つである。(85)
- テンプレートの活用で有益なのが`関数オブジェクト（function object）`/` ファンクター（functor）`である：あたかも関数のようにオブジェクトを呼び出すことができる
  - 汎用アルゴリズムの中核となる演算を指定するための、関数オブジェクトを`ポリシーオブジェクト(policy object)` という。
  - 関数オブジェクトを簡潔な内容であれば、ラムダ式（lambda function）を使って全く同じオブジェクトを生成することができる.(`[&](int a) { return a < x; }`)
    - `[&], キャプチャ並び(capture list)`：使っている`局所名（x など）`を参照を介してアクセスすることを表す
    - x だけキャプチャしたい場合 `[&x]`, x のコピーとしてオブジェクとを生成した場合は`[=x]`と記述
- `conditional_variable`: lock とイベント待ち: 他のスレッドの結果によってなんならかの条件が成立するまで、別のスレッドを待機させる、と言ったことが可能.(127)
  - 関数の中では、初めに `mutex` を取得し、`conditional_variable.wait(unique_lock<mutex>)` で、`mutex` を解放し wait する。condition が成立したら（待機が終わったら）、再度 `unique_lock<mutex>` を取得し、ロックをかける。
  - condition が成立したことを通知するには、`conditional_variable.notify_one()` で行う
- `tag dispatch（タグ指定）`: overload, single/multi dispatch を前提とした機能で、iterator pattern をアルゴリズムに適用したもの。タグと呼ばれる、組み込みの機能（例えば、`std::random_access_iterator_tag（for vector）`, `std::forward_iterator_tag（for forward_list）`）を関数の引数として使い、コンパイル時に複数のアルゴリズムのうちから１つ選択することができる機能。このタグを取得するために、`iterator_traits` (この場合は container )などから tag を取得することができる。また、こういった関数（/アルゴリズム: 引数あるいは返却値として、ある型が与えられて、コンパイル時に評価される関数）を`型関数(type function)`と言う。(132)
- `型述語`：型に関する基本的な情報を返却するための単純な`型関数`である。このような述語（predicate）は、`<type_traits>`で提供される
- `make_pair()` を使うと、明示的な型の記述が不要になるため pair の作成が容易になる(135)
- その機能に、理屈通りで容易に実装できる別の方法が複数あれば、その機能は、`定義されない（undefined）`ではなく、`指定されない（unspecified）`あるいは、`処理系定義（implementation defined）`である(144)
- 標準が指定しない、あるいは、定義しない、とするものを使わないように努力することは、そのための時間と労力に見合うはずである(145)
- `void`: `返却値を返さない関数の型`、または`型がわからないオブジェクトを指すポインタの型`として利用(157)
- `size_t`: 処理系定義の符号無し整数型、`ptrdiff_t`: 要素数を求めるための、ポインタどうしの差の演算結果を保持できる. このように標準ヘッダは処理系に依存しない型の大きさを定義した`型別名`を提供する（`<cstdint>`, `<stddef>`など）
- `値を指定する宣言`は、全て`定義`である(162)
- `関数定義`と`名前空間定義`を除くと、`全ての宣言`はセミコロンで終了する(162)
- `予約済みの名前`：`下線で始まる非局所変数`, `２個の下線を含む名前`、`下線で始まって直後に大文字が続く名前`など（`_class`, `trouble__ahead`, `_Foo` など）
- `参照はずし`: C++ では参照は、式の中で暗黙裏に反証外しを行われている(Go と同じ) `void g(int& v) { auto x = v;}` この場合、`&v` は暗黙裏に参照外しされ、`v` となる。もし参照としてオブジェクトを保持したいなら、`auto &x = v;` とすれば良い.
- `配列`を`空き領域`に割り当てた場合（`new int[40]`をした場合。）は、必ず使用後に１度削除しなければならない（`delete[]`）。`スタック領域`（`int a[20]`）や、静的に割り当てた場合（`静的記憶域`に格納した場合、global, 関数・クラス内の static をつけて宣言した変数など）は`delete[]`してはいけない。
- C と同様に初期化された配列に再代入することはできない。そのためオブジェクトの集合を代入したいときは、vector, array, valarray を使う(184)
- `文字列リテラル`: C++ では const ととして定義する。もし、非 const にしたいなら配列で宣言すること(185):
  - const: `const char* p = "Plate"` (const は静的に割り当てられるため、関数の返却値としても安全に利用できる（関数終了後も存在し続ける・アドレスが変わらない・move しない・）)
  - 非 const: `char p[] = "Plate"`
  - さらに文字列リテラルは最適化のため全く同じ内容の文字列を同じアドレスとして保持する場合がある。その際に別々の変数を比較して同じアドレスを指しているかどうか（同じ文字列かどうではなく）で確認することができる
- `ポインタ`の扱いは大変（メンバへのアクセス方法などの違い）なので、`参照`を利用する
  - `参照`の主な用途は、`関数`あるいは`多重定義された演算子`の`引数`と`返却値`
  - 参照の種類:
    - `左辺値参照`(`lvalue reference`): その値を変更したいオブジェクトへの参照(`v[2] = 7;`)
    - `const 参照`(`const reference`): その値を変更したくないオブジェクトへの参照（定数など）(`f(const &v){...}`)
    - `右辺値参照`(`rvalue reference`): 利用した後で、その値を維持する必要がないオブジェクト（例えば、一時オブジェクト）への参照(`v.push_back(v[2]);`)
  - 参照はオブジェクトを指す. 参照から参照先のオブジェクトへのポインタを取得する場合は、`int var = 0; int &rr {val}; int *p = &rr;` のように`&rr`する
  - `単なる参照`と`const の参照`では初期化時の挙動が異なる
    - `単なる参照`: 異なる型で初期化することはできない
    - `const の参照`: 異なる型で初期化することはできる. 異なる場合、const への参照型へキャストされる. 例えば、`const double &cdr {1}` は double 型になる(199)
      - このキャストが行われる際には、temp の変数が作成されこれは参照のスコープかを抜け出すまで存在し続ける(199)
    - `Map` 型の場合は線形探索などの函数の返却値に参照が使用される。と言うのも、返却値の value をよく更新されるのに使用されることが多いからである。
